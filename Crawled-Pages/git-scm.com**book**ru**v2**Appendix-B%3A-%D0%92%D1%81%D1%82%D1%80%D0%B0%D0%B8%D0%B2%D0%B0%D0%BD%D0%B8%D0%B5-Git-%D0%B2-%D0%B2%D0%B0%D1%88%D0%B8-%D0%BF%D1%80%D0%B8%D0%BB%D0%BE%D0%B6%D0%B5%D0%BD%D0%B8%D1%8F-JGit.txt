        About
            Branching and Merging
            Small and Fast
            Distributed
            Data Assurance
            Staging Area
            Free and Open Source
            Trademark
        Documentation
            Reference
            Book
            Videos
            External Links
        Downloads
            GUI Clients
            Logos
        Community
This book is available in
  English.
  Full translation available in
    български език,
    Deutsch,
    Español,
    Français,
    Ελληνικά,
    日本語,
    한국어,
    Nederlands,
    Русский,
    Slovenščina,
    Tagalog,
    Українська
    简体中文,
  Partial translations available in
    Čeština,
    Македонски,
    Polski,
    Српски,
    Ўзбекча,
    繁體中文,
  Translations started for
    azərbaycan dili,
    Беларуская,
    فارسی,
    Indonesian,
    Italiano,
    Bahasa Melayu,
    Português (Brasil),
    Português (Portugal),
    Svenska,
    Türkçe.
The source of this book is  hosted on GitHub.
Patches, suggestions and comments are welcome.
  Chapters ▾
  1. Введение
          1.1
          О системе контроля версий 
          1.2
          Краткая история Git 
          1.3
          Основы Git 
          1.4
          Командная строка 
          1.5
          Установка Git 
          1.6
          Первоначальная настройка Git 
          1.7
          Как получить помощь? 
          1.8
          Заключение 
  2. Основы Git
          2.1
          Создание Git-репозитория 
          2.2
          Запись изменений в репозиторий 
          2.3
          Просмотр истории коммитов 
          2.4
          Операции отмены 
          2.5
          Работа с удалёнными репозиториями 
          2.6
          Работа с метками 
          2.7
          Псевдонимы в Git 
          2.8
          Заключение 
  3. Ветвление в Git
          3.1
          О ветвлении в двух словах 
          3.2
          Основы ветвления и слияния 
          3.3
          Управление ветками 
          3.4
          Работа с ветками 
          3.5
          Удалённые ветки 
          3.6
          Перебазирование 
          3.7
          Заключение 
  4. Git на сервере
          4.1
          Протоколы 
          4.2
          Установка Git на сервер 
          4.3
          Генерация открытого SSH ключа 
          4.4
          Настраиваем сервер 
          4.5
          Git-демон 
          4.6
          Умный HTTP 
          4.7
          GitWeb 
          4.8
          GitLab 
          4.9
          Git-хостинг 
          4.10
          Заключение 
  5. Распределенный Git
          5.1
          Распределенный рабочий процесс 
          5.2
          Участие в проекте 
          5.3
          Сопровождение проекта 
          5.4
          Заключение 
  6. GitHub
          6.1
          Настройка и конфигурация учетной записи 
          6.2
          Внесение собственного вклада в проекты 
          6.3
          Сопровождение проекта 
          6.4
          Управление организацией 
          6.5
          Scripting GitHub 
          6.6
          Заключение 
  7. Инструменты Git
          7.1
          Выбор ревизии 
          7.2
          Интерактивное индексирование 
          7.3
          Прибережение и очистка 
          7.4
          Подпись результатов вашей работы 
          7.5
          Поиск 
          7.6
          Исправление истории 
          7.7
          Раскрытие тайн reset 
          7.8
          Продвинутое слияние 
          7.9
          Rerere 
          7.10
          Обнаружение ошибок с помощью Git 
          7.11
          Подмодули 
          7.12
          Создание пакетов 
          7.13
          Замена 
          7.14
          Хранилище учётных данных 
          7.15
          Заключение 
  8. Настройка Git
          8.1
          Конфигурация Git 
          8.2
          Атрибуты Git 
          8.3
          Хуки в Git 
          8.4
          Пример принудительной политики Git 
          8.5
          Заключение 
  9. Git и другие системы контроля версий
          9.1
          Git как клиент 
          9.2
          Миграция на Git 
          9.3
          Заключение 
  10. Git изнутри
          10.1
          Сантехника и Фарфор 
          10.2
          Объекты Git 
          10.3
          Ссылки в Git 
          10.4
          Pack-файлы 
          10.5
          Спецификации ссылок 
          10.6
          Протоколы передачи данных 
          10.7
          Обслуживание репозитория и восстановление данных 
          10.8
          Переменные окружения 
          10.9
          Заключение 
  A1. Appendix A: Git в других окружениях
          A1.1
          Графические интерфейсы 
          A1.2
          Git в Visual Studio 
          A1.3
          Git в Visual Studio Code 
          A1.4
          Git в Eclipse 
          A1.5
          Git в IntelliJ / PyCharm / WebStorm / PhpStorm / RubyMine 
          A1.6
          Git в Sublime Text 
          A1.7
          Git в Bash 
          A1.8
          Git в Zsh 
          A1.9
          Git в Powershell 
          A1.10
          Заключение 
  A2. Appendix B: Встраивание Git в ваши приложения
          A2.1
          Git из командной строки 
          A2.2
          Libgit2 
          A2.3
          JGit 
          A2.4
          go-git 
          A2.5
          Dulwich 
  A3. Appendix C: Команды Git
          A3.1
          Настройка и конфигурация 
          A3.2
          Клонирование и создание репозиториев 
          A3.3
          Основные команды 
          A3.4
          Ветвление и слияния 
          A3.5
          Совместная работа и обновление проектов 
          A3.6
          Осмотр и сравнение 
          A3.7
          Отладка 
          A3.8
          Внесение исправлений 
          A3.9
          Работа с помощью электронной почты 
          A3.10
          Внешние системы 
          A3.11
          Администрирование 
          A3.12
          Низкоуровневые команды 
      2nd Edition
    A2.3 Appendix B: Встраивание Git в ваши приложения - JGit
JGit
Если вы хотите использовать Git из Java-программ, существует библиотека для работы с Git, называемая JGit.
Она достаточно полно реализует функциональность Git, написана на чистом Java и широко используется Java сообществом.
Проект JGit находится под опекой Eclipse и расположен по адресу http://www.eclipse.org/jgit.
Приступая к работе
Существует несколько способов добавить JGit в проект и начать писать код с использованием предоставляемого API.
Возможно, самый простой путь — использование Maven: подключение библиотеки происходит путём добавления следующих строк в секцию &lt;dependencies&gt; в вашем pom.xml:
&lt;dependency&gt;
    &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt;
    &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt;
    &lt;version&gt;3.5.0.201409260305-r&lt;/version&gt;
&lt;/dependency&gt;
С момента выхода книги скорее всего появились новые версии JGit, проверьте обновления на http://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit.
После обновления конфигурации Maven автоматически скачает JGit нужной версии и добавит её к проекту.
Если вы управляете зависимостями вручную, собранные бинарные пакеты JGit доступны на http://www.eclipse.org/jgit/download.
Использовать их в своём проекте можно следующим способом:
javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.java
java -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App
Служебный API
У JGit есть два уровня API: служебный ("plumbing" API, "трубопровод") и пользовательский ("porcelain" API, "фарфор").
Эта терминология заимствована из самого Git и JGit разделён на две части: "фарфоровый" API предоставляет удобные методы для распространённых задач прикладного уровня (тех, для решения которых вы бы использовали обычные Git-команды) и "сантехнический" API для прямого взаимодействия с низкоуровневыми объектами репозитория.
Начальная точка большинства сценариев использования JGit — класс Repository и первое, что необходимо сделать — это создать объект данного класса.
Для репозиториев основанных на файловой системе (да, JGit позволяет использовать другие модели хранения) эта задача решается с помощью класса FileRepositoryBuilder:
// Создание нового репозитория; директория должна существовать
Repository newlyCreatedRepo = FileRepositoryBuilder.create(
    new File("/tmp/new_repo/.git"));
newlyCreatedRepo.create();
// Открыть существующий репозиторий
Repository existingRepo = new FileRepositoryBuilder()
    .setGitDir(new File("my_repo/.git"))
    .build();
Вызовы методов билдера можно объединять в цепочку чтобы указать всю информацию для поиска репозитория независимо от того, знает ли ваша программа его точное месторасположение или нет.
Можно читать системные переменные (.readEnvironment()), начать поиск с произвольного места в рабочей директории (.setWorkTree(…).findGitDir()), или просто открыть директорию .git по указанному пути.
После создания объекта типа Repository, вам будет доступен широкий набор операций над ним.
Краткий пример:
// Получение ссылки
Ref master = repo.getRef("master");
// Получение объекта, на который она указывает
ObjectId masterTip = master.getObjectId();
// Использование rev-parse выражений
ObjectId obj = repo.resolve("HEAD^{tree}");
// Получение "сырых" данных
ObjectLoader loader = repo.open(masterTip);
loader.copyTo(System.out);
// Создание ветки
RefUpdate createBranch1 = repo.updateRef("refs/heads/branch1");
createBranch1.setNewObjectId(masterTip);
createBranch1.update();
// Удаление ветки
RefUpdate deleteBranch1 = repo.updateRef("refs/heads/branch1");
deleteBranch1.setForceUpdate(true);
deleteBranch1.delete();
// Работа с конфигурацией
Config cfg = repo.getConfig();
String name = cfg.getString("user", null, "name");
Тут происходит много интересного, давайте разберёмся по порядку.
Первая строка получает указатель на ссылку master.
JGit автоматически получает актуальную информацию о master, хранимую по пути refs/heads/master, и возвращает объект, предоставляющий доступ к информации о ссылке.
Вы можете получить имя (.getName()), а также целевой объект прямой ссылки (.getObjectId()) или ссылку, на которую указывает другая символьная ссылка (.getTarget()).
Объекты типа Ref также служат для представления ссылок на теги и самих тегов; вы можете узнать, является ли тег "конечным" ("peeled"), т.е. ссылается ли он на целевой объект потенциально длинной цепи тегов.
Вторая строка получает объект на который указывает ссылка master в виде ObjectId.
ObjectId представляют SHA-1 хэш объекта, который, возможно, сохранён внутри базы данных объектов Git.
Следующая строка похожа на предыдущую, но используется rev-parse синтаксис (см. детали в Ссылки на ветки); вы можете использовать любой, подходящий формат и JGit вернёт либо валидный ObjectId для указанного объекта, либо null.
Следующие две строки показывают, как можно получить содержимое объекта.
В этом примере мы используем ObjectLoader.copyTo() чтобы передать содержимое файла прямиком в stdout, но у ObjectLoader есть методы для чтения типа и размера объекта, а также для считывания объекта в виде массива байтов.
Для больших объектов (у которых .isLarge() возвращает true) можно использовать метод .openStream() для открытия потока последовательного чтения объекта без полной загрузки в память.
Следующие строки показывают, как создать новую ветку.
Мы создаём объект типа RefUpdate, устанавливаем некоторые параметры и вызываем метод .update() чтобы инициировать изменение.
После этого мы удаляем эту же ветку.
Обратите внимание на необходимость вызова .setForceUpdate(true) для корректной работы; иначе вызов .delete() вернёт REJECTED и ничего не произойдёт.
Последний кусок кода показывает как получить параметр user.name из файлов конфигурации Git.
Созданный объект Config будет использовать открытый ранее репозиторий для чтения локальной конфигурации, также он автоматически находит файлы глобальной и системной конфигурации и использует их для чтения значений.
Это лишь малая часть служебного API JGit; в вашем распоряжении окажется гораздо больше классов и методов.
Мы не показали как JGit обрабатывает ошибки.
JGit использует механизм исключений Java; иногда он бросает стандартные исключения (типа IOException), иногда — специфичные для JGit (например NoRemoteRepositoryException, CorruptObjectException и NoMergeBaseException).
Пользовательский API
Служебные API достаточно всеобъемлющи, но сложны в использовании для простых задач вроде добавления файла в индекс или создания нового коммита.
У JGit есть API более высокого уровня, входная точка в который — это класс Git:
Repository repo;
// создание репозитория...
Git git = new Git(repo);
В классе Git можно найти отличный набор высокоуровневых "текучих" методов (builder-style / fluent interface).
Давайте взглянем на пример — результат выполнения этого кода напоминает git ls-remote:
CredentialsProvider cp = new UsernamePasswordCredentialsProvider("username", "p4ssw0rd");
Collection&lt;Ref&gt; remoteRefs = git.lsRemote()
    .setCredentialsProvider(cp)
    .setRemote("origin")
    .setTags(true)
    .setHeads(false)
    .call();
for (Ref ref : remoteRefs) {
    System.out.println(ref.getName() + " -&gt; " + ref.getObjectId().name());
}
Тут показан частый случай использования класса Git: методы возвращают тот же объект, на котором вызваны, что позволяет чередовать их друг за другом, устанавливая параметры, а выполнение происходит при вызове .call().
В этом примере мы запрашиваем с удалённого репозитория origin список тегов, исключая ветки.
Обратите внимание на использование класса CredentialsProvider для аутентификации.
Множество команд доступно в классе Git, включая такие как add, blame, commit, clean, push, rebase, revert, reset и другие.
Дополнительные материалы
Это лишь небольшой пример всех возможностей JGit.
Если вы заинтересованы в более детальной работе с JGit, вот список источников информации для старта:
Официальная документация по JGit API доступна в Интернете на http://download.eclipse.org/jgit/docs/latest/apidocs.
Это обыкновенный Javadoc, так что ваша любимая IDE может скачать её и использовать оффлайн.
"Поваренная книга" JGit, расположенная по адресу https://github.com/centic9/jgit-cookbook, включает в себя много готовых "рецептов" использования JGit для решения тех или иных задач.
prev | next
    About this site
    Patches, suggestions, and comments are welcome.
    Git is a member of Software Freedom Conservancy
