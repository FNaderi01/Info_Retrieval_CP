      Skip to content
                Sign up
                    Why GitHub?
                    Features →
                      Code review
                      Project management
                      Integrations
                      Actions
                      Packages
                      Security
                      Team management
                      Hosting
                      Mobile
                      Customer stories →
                      Security →
                Team
                Enterprise
                    Explore
                      Explore GitHub →
                    Learn &amp; contribute
                      Topics
                        Collections
                      Trending
                      Learning Lab
                      Open source guides
                    Connect with others
                      Events
                      Community forum
                      GitHub Education
                      GitHub Stars program
                Marketplace
                    Pricing
                    Plans →
                      Compare plans
                      Contact Sales
                      Nonprofit →
                      Education →
     -->
        In this repository
        All GitHub
      ↵
      Jump to
      ↵
    No suggested jump to results
        In this repository
        All GitHub
      ↵
      Jump to
      ↵
        In this repository
        All GitHub
      ↵
      Jump to
      ↵
          Sign in
              Sign up
      {{ message }}
      newren
    /
    git
    forked from git/git
    Watch
      1
      Star
      1
          Fork
        20k
            Code
            Pull requests
              0
            Actions
            Projects
              0
            Security
            Insights
            More
                    Code
                    Pull requests
                    Actions
                    Projects
                    Security
                    Insights
    Permalink
          Dismiss
        Join GitHub today
        GitHub is home to over 50 million developers working together to host and review code, manage projects, and build software together.
        Sign up
      master
        git/transport.c
        Go to file
                Go to file
                T
                  Go to line
                  L
                Copy path
          Cannot retrieve contributors at this time
      1396 lines (1220 sloc)
    36 KB
      Raw
        Blame
        #include "cache.h"
        #include "config.h"
        #include "transport.h"
        #include "run-command.h"
        #include "pkt-line.h"
        #include "fetch-pack.h"
        #include "remote.h"
        #include "connect.h"
        #include "send-pack.h"
        #include "walker.h"
        #include "bundle.h"
        #include "dir.h"
        #include "refs.h"
        #include "refspec.h"
        #include "branch.h"
        #include "url.h"
        #include "submodule.h"
        #include "string-list.h"
        #include "sha1-array.h"
        #include "sigchain.h"
        #include "transport-internal.h"
        #include "protocol.h"
        #include "object-store.h"
        #include "color.h"
        static int transport_use_color = -1;
        static char transport_colors[][COLOR_MAXLEN] = {
        	GIT_COLOR_RESET,
        	GIT_COLOR_RED		/* REJECTED */
        };
        enum color_transport {
        	TRANSPORT_COLOR_RESET = 0,
        	TRANSPORT_COLOR_REJECTED = 1
        };
        static int transport_color_config(void)
        {
        	const char *keys[] = {
        		"color.transport.reset",
        		"color.transport.rejected"
        	}, *key = "color.transport";
        	char *value;
        	int i;
        	static int initialized;
        	if (initialized)
        		return 0;
        	initialized = 1;
        	if (!git_config_get_string(key, &amp;value))
        		transport_use_color = git_config_colorbool(key, value);
        	if (!want_color_stderr(transport_use_color))
        		return 0;
        	for (i = 0; i &lt; ARRAY_SIZE(keys); i++)
        		if (!git_config_get_string(keys[i], &amp;value)) {
        			if (!value)
        				return config_error_nonbool(keys[i]);
        			if (color_parse(value, transport_colors[i]) &lt; 0)
        				return -1;
        		}
        	return 0;
        }
        static const char *transport_get_color(enum color_transport ix)
        {
        	if (want_color_stderr(transport_use_color))
        		return transport_colors[ix];
        	return "";
        }
        static void set_upstreams(struct transport *transport, struct ref *refs,
        	int pretend)
        {
        	struct ref *ref;
        	for (ref = refs; ref; ref = ref-&gt;next) {
        		const char *localname;
        		const char *tmp;
        		const char *remotename;
        		int flag = 0;
        		/*
        		 * Check suitability for tracking. Must be successful /
        		 * already up-to-date ref create/modify (not delete).
        		 */
        		if (ref-&gt;status != REF_STATUS_OK &amp;&amp;
        			ref-&gt;status != REF_STATUS_UPTODATE)
        			continue;
        		if (!ref-&gt;peer_ref)
        			continue;
        		if (is_null_oid(&amp;ref-&gt;new_oid))
        			continue;
        		/* Follow symbolic refs (mainly for HEAD). */
        		localname = ref-&gt;peer_ref-&gt;name;
        		remotename = ref-&gt;name;
        		tmp = resolve_ref_unsafe(localname, RESOLVE_REF_READING,
        					 NULL, &amp;flag);
        		if (tmp &amp;&amp; flag &amp; REF_ISSYMREF &amp;&amp;
        			starts_with(tmp, "refs/heads/"))
        			localname = tmp;
        		/* Both source and destination must be local branches. */
        		if (!localname || !starts_with(localname, "refs/heads/"))
        			continue;
        		if (!remotename || !starts_with(remotename, "refs/heads/"))
        			continue;
        		if (!pretend)
        			install_branch_config(BRANCH_CONFIG_VERBOSE,
        				localname + 11, transport-&gt;remote-&gt;name,
        				remotename);
        		else
        			printf(_("Would set upstream of '%s' to '%s' of '%s'\n"),
        				localname + 11, remotename + 11,
        				transport-&gt;remote-&gt;name);
        	}
        }
        struct bundle_transport_data {
        	int fd;
        	struct bundle_header header;
        };
        static struct ref *get_refs_from_bundle(struct transport *transport,
        					int for_push,
        					const struct argv_array *ref_prefixes)
        {
        	struct bundle_transport_data *data = transport-&gt;data;
        	struct ref *result = NULL;
        	int i;
        	if (for_push)
        		return NULL;
        	if (data-&gt;fd &gt; 0)
        		close(data-&gt;fd);
        	data-&gt;fd = read_bundle_header(transport-&gt;url, &amp;data-&gt;header);
        	if (data-&gt;fd &lt; 0)
        		die(_("could not read bundle '%s'"), transport-&gt;url);
        	for (i = 0; i &lt; data-&gt;header.references.nr; i++) {
        		struct ref_list_entry *e = data-&gt;header.references.list + i;
        		struct ref *ref = alloc_ref(e-&gt;name);
        		oidcpy(&amp;ref-&gt;old_oid, &amp;e-&gt;oid);
        		ref-&gt;next = result;
        		result = ref;
        	}
        	return result;
        }
        static int fetch_refs_from_bundle(struct transport *transport,
        			       int nr_heads, struct ref **to_fetch)
        {
        	struct bundle_transport_data *data = transport-&gt;data;
        	return unbundle(the_repository, &amp;data-&gt;header, data-&gt;fd,
        			transport-&gt;progress ? BUNDLE_VERBOSE : 0);
        }
        static int close_bundle(struct transport *transport)
        {
        	struct bundle_transport_data *data = transport-&gt;data;
        	if (data-&gt;fd &gt; 0)
        		close(data-&gt;fd);
        	free(data);
        	return 0;
        }
        struct git_transport_data {
        	struct git_transport_options options;
        	struct child_process *conn;
        	int fd[2];
        	unsigned got_remote_heads : 1;
        	enum protocol_version version;
        	struct oid_array extra_have;
        	struct oid_array shallow;
        };
        static int set_git_option(struct git_transport_options *opts,
        			  const char *name, const char *value)
        {
        	if (!strcmp(name, TRANS_OPT_UPLOADPACK)) {
        		opts-&gt;uploadpack = value;
        		return 0;
        	} else if (!strcmp(name, TRANS_OPT_RECEIVEPACK)) {
        		opts-&gt;receivepack = value;
        		return 0;
        	} else if (!strcmp(name, TRANS_OPT_THIN)) {
        		opts-&gt;thin = !!value;
        		return 0;
        	} else if (!strcmp(name, TRANS_OPT_FOLLOWTAGS)) {
        		opts-&gt;followtags = !!value;
        		return 0;
        	} else if (!strcmp(name, TRANS_OPT_KEEP)) {
        		opts-&gt;keep = !!value;
        		return 0;
        	} else if (!strcmp(name, TRANS_OPT_UPDATE_SHALLOW)) {
        		opts-&gt;update_shallow = !!value;
        		return 0;
        	} else if (!strcmp(name, TRANS_OPT_DEPTH)) {
        		if (!value)
        			opts-&gt;depth = 0;
        		else {
        			char *end;
        			opts-&gt;depth = strtol(value, &amp;end, 0);
        			if (*end)
        				die(_("transport: invalid depth option '%s'"), value);
        		}
        		return 0;
        	} else if (!strcmp(name, TRANS_OPT_DEEPEN_SINCE)) {
        		opts-&gt;deepen_since = value;
        		return 0;
        	} else if (!strcmp(name, TRANS_OPT_DEEPEN_NOT)) {
        		opts-&gt;deepen_not = (const struct string_list *)value;
        		return 0;
        	} else if (!strcmp(name, TRANS_OPT_DEEPEN_RELATIVE)) {
        		opts-&gt;deepen_relative = !!value;
        		return 0;
        	} else if (!strcmp(name, TRANS_OPT_FROM_PROMISOR)) {
        		opts-&gt;from_promisor = !!value;
        		return 0;
        	} else if (!strcmp(name, TRANS_OPT_NO_DEPENDENTS)) {
        		opts-&gt;no_dependents = !!value;
        		return 0;
        	} else if (!strcmp(name, TRANS_OPT_LIST_OBJECTS_FILTER)) {
        		parse_list_objects_filter(&amp;opts-&gt;filter_options, value);
        		return 0;
        	}
        	return 1;
        }
        static int connect_setup(struct transport *transport, int for_push)
        {
        	struct git_transport_data *data = transport-&gt;data;
        	int flags = transport-&gt;verbose &gt; 0 ? CONNECT_VERBOSE : 0;
        	if (data-&gt;conn)
        		return 0;
        	switch (transport-&gt;family) {
        	case TRANSPORT_FAMILY_ALL: break;
        	case TRANSPORT_FAMILY_IPV4: flags |= CONNECT_IPV4; break;
        	case TRANSPORT_FAMILY_IPV6: flags |= CONNECT_IPV6; break;
        	}
        	data-&gt;conn = git_connect(data-&gt;fd, transport-&gt;url,
        				 for_push ? data-&gt;options.receivepack :
        				 data-&gt;options.uploadpack,
        				 flags);
        	return 0;
        }
        static void die_if_server_options(struct transport *transport)
        {
        	if (!transport-&gt;server_options || !transport-&gt;server_options-&gt;nr)
        		return;
        	advise(_("see protocol.version in 'git help config' for more details"));
        	die(_("server options require protocol version 2 or later"));
        }
        /*
         * Obtains the protocol version from the transport and writes it to
         * transport-&gt;data-&gt;version, first connecting if not already connected.
         *
         * If the protocol version is one that allows skipping the listing of remote
         * refs, and must_list_refs is 0, the listing of remote refs is skipped and
         * this function returns NULL. Otherwise, this function returns the list of
         * remote refs.
         */
        static struct ref *handshake(struct transport *transport, int for_push,
        			     const struct argv_array *ref_prefixes,
        			     int must_list_refs)
        {
        	struct git_transport_data *data = transport-&gt;data;
        	struct ref *refs = NULL;
        	struct packet_reader reader;
        	connect_setup(transport, for_push);
        	packet_reader_init(&amp;reader, data-&gt;fd[0], NULL, 0,
        			   PACKET_READ_CHOMP_NEWLINE |
        			   PACKET_READ_GENTLE_ON_EOF |
        			   PACKET_READ_DIE_ON_ERR_PACKET);
        	data-&gt;version = discover_version(&amp;reader);
        	switch (data-&gt;version) {
        	case protocol_v2:
        		if (must_list_refs)
        			get_remote_refs(data-&gt;fd[1], &amp;reader, &amp;refs, for_push,
        					ref_prefixes,
        					transport-&gt;server_options);
        		break;
        	case protocol_v1:
        	case protocol_v0:
        		die_if_server_options(transport);
        		get_remote_heads(&amp;reader, &amp;refs,
        				 for_push ? REF_NORMAL : 0,
        				 &amp;data-&gt;extra_have,
        				 &amp;data-&gt;shallow);
        		break;
        	case protocol_unknown_version:
        		BUG("unknown protocol version");
        	}
        	data-&gt;got_remote_heads = 1;
        	if (reader.line_peeked)
        		BUG("buffer must be empty at the end of handshake()");
        	return refs;
        }
        static struct ref *get_refs_via_connect(struct transport *transport, int for_push,
        					const struct argv_array *ref_prefixes)
        {
        	return handshake(transport, for_push, ref_prefixes, 1);
        }
        static int fetch_refs_via_pack(struct transport *transport,
        			       int nr_heads, struct ref **to_fetch)
        {
        	int ret = 0;
        	struct git_transport_data *data = transport-&gt;data;
        	struct ref *refs = NULL;
        	struct fetch_pack_args args;
        	struct ref *refs_tmp = NULL;
        	memset(&amp;args, 0, sizeof(args));
        	args.uploadpack = data-&gt;options.uploadpack;
        	args.keep_pack = data-&gt;options.keep;
        	args.lock_pack = 1;
        	args.use_thin_pack = data-&gt;options.thin;
        	args.include_tag = data-&gt;options.followtags;
        	args.verbose = (transport-&gt;verbose &gt; 1);
        	args.quiet = (transport-&gt;verbose &lt; 0);
        	args.no_progress = !transport-&gt;progress;
        	args.depth = data-&gt;options.depth;
        	args.deepen_since = data-&gt;options.deepen_since;
        	args.deepen_not = data-&gt;options.deepen_not;
        	args.deepen_relative = data-&gt;options.deepen_relative;
        	args.check_self_contained_and_connected =
        		data-&gt;options.check_self_contained_and_connected;
        	args.cloning = transport-&gt;cloning;
        	args.update_shallow = data-&gt;options.update_shallow;
        	args.from_promisor = data-&gt;options.from_promisor;
        	args.no_dependents = data-&gt;options.no_dependents;
        	args.filter_options = data-&gt;options.filter_options;
        	args.stateless_rpc = transport-&gt;stateless_rpc;
        	args.server_options = transport-&gt;server_options;
        	args.negotiation_tips = data-&gt;options.negotiation_tips;
        	if (!data-&gt;got_remote_heads) {
        		int i;
        		int must_list_refs = 0;
        		for (i = 0; i &lt; nr_heads; i++) {
        			if (!to_fetch[i]-&gt;exact_oid) {
        				must_list_refs = 1;
        				break;
        			}
        		}
        		refs_tmp = handshake(transport, 0, NULL, must_list_refs);
        	}
        	switch (data-&gt;version) {
        	case protocol_v2:
        		refs = fetch_pack(&amp;args, data-&gt;fd,
        				  refs_tmp ? refs_tmp : transport-&gt;remote_refs,
        				  to_fetch, nr_heads, &amp;data-&gt;shallow,
        				  &amp;transport-&gt;pack_lockfile, data-&gt;version);
        		break;
        	case protocol_v1:
        	case protocol_v0:
        		die_if_server_options(transport);
        		refs = fetch_pack(&amp;args, data-&gt;fd,
        				  refs_tmp ? refs_tmp : transport-&gt;remote_refs,
        				  to_fetch, nr_heads, &amp;data-&gt;shallow,
        				  &amp;transport-&gt;pack_lockfile, data-&gt;version);
        		break;
        	case protocol_unknown_version:
        		BUG("unknown protocol version");
        	}
        	close(data-&gt;fd[0]);
        	close(data-&gt;fd[1]);
        	if (finish_connect(data-&gt;conn))
        		ret = -1;
        	data-&gt;conn = NULL;
        	data-&gt;got_remote_heads = 0;
        	data-&gt;options.self_contained_and_connected =
        		args.self_contained_and_connected;
        	data-&gt;options.connectivity_checked = args.connectivity_checked;
        	if (refs == NULL)
        		ret = -1;
        	if (report_unmatched_refs(to_fetch, nr_heads))
        		ret = -1;
        	free_refs(refs_tmp);
        	free_refs(refs);
        	return ret;
        }
        static int push_had_errors(struct ref *ref)
        {
        	for (; ref; ref = ref-&gt;next) {
        		switch (ref-&gt;status) {
        		case REF_STATUS_NONE:
        		case REF_STATUS_UPTODATE:
        		case REF_STATUS_OK:
        			break;
        		default:
        			return 1;
        		}
        	}
        	return 0;
        }
        int transport_refs_pushed(struct ref *ref)
        {
        	for (; ref; ref = ref-&gt;next) {
        		switch(ref-&gt;status) {
        		case REF_STATUS_NONE:
        		case REF_STATUS_UPTODATE:
        			break;
        		default:
        			return 1;
        		}
        	}
        	return 0;
        }
        void transport_update_tracking_ref(struct remote *remote, struct ref *ref, int verbose)
        {
        	struct refspec_item rs;
        	if (ref-&gt;status != REF_STATUS_OK &amp;&amp; ref-&gt;status != REF_STATUS_UPTODATE)
        		return;
        	rs.src = ref-&gt;name;
        	rs.dst = NULL;
        	if (!remote_find_tracking(remote, &amp;rs)) {
        		if (verbose)
        			fprintf(stderr, "updating local tracking ref '%s'\n", rs.dst);
        		if (ref-&gt;deletion) {
        			delete_ref(NULL, rs.dst, NULL, 0);
        		} else
        			update_ref("update by push", rs.dst, &amp;ref-&gt;new_oid,
        				   NULL, 0, 0);
        		free(rs.dst);
        	}
        }
        static void print_ref_status(char flag, const char *summary,
        			     struct ref *to, struct ref *from, const char *msg,
        			     int porcelain, int summary_width)
        {
        	if (porcelain) {
        		if (from)
        			fprintf(stdout, "%c\t%s:%s\t", flag, from-&gt;name, to-&gt;name);
        		else
        			fprintf(stdout, "%c\t:%s\t", flag, to-&gt;name);
        		if (msg)
        			fprintf(stdout, "%s (%s)\n", summary, msg);
        		else
        			fprintf(stdout, "%s\n", summary);
        	} else {
        		const char *red = "", *reset = "";
        		if (push_had_errors(to)) {
        			red = transport_get_color(TRANSPORT_COLOR_REJECTED);
        			reset = transport_get_color(TRANSPORT_COLOR_RESET);
        		}
        		fprintf(stderr, " %s%c %-*s%s ", red, flag, summary_width,
        			summary, reset);
        		if (from)
        			fprintf(stderr, "%s -&gt; %s", prettify_refname(from-&gt;name), prettify_refname(to-&gt;name));
        		else
        			fputs(prettify_refname(to-&gt;name), stderr);
        		if (msg) {
        			fputs(" (", stderr);
        			fputs(msg, stderr);
        			fputc(')', stderr);
        		}
        		fputc('\n', stderr);
        	}
        }
        static void print_ok_ref_status(struct ref *ref, int porcelain, int summary_width)
        {
        	if (ref-&gt;deletion)
        		print_ref_status('-', "[deleted]", ref, NULL, NULL,
        				 porcelain, summary_width);
        	else if (is_null_oid(&amp;ref-&gt;old_oid))
        		print_ref_status('*',
        			(starts_with(ref-&gt;name, "refs/tags/") ? "[new tag]" :
        			"[new branch]"),
        			ref, ref-&gt;peer_ref, NULL, porcelain, summary_width);
        	else {
        		struct strbuf quickref = STRBUF_INIT;
        		char type;
        		const char *msg;
        		strbuf_add_unique_abbrev(&amp;quickref, &amp;ref-&gt;old_oid,
        					 DEFAULT_ABBREV);
        		if (ref-&gt;forced_update) {
        			strbuf_addstr(&amp;quickref, "...");
        			type = '+';
        			msg = "forced update";
        		} else {
        			strbuf_addstr(&amp;quickref, "..");
        			type = ' ';
        			msg = NULL;
        		}
        		strbuf_add_unique_abbrev(&amp;quickref, &amp;ref-&gt;new_oid,
        					 DEFAULT_ABBREV);
        		print_ref_status(type, quickref.buf, ref, ref-&gt;peer_ref, msg,
        				 porcelain, summary_width);
        		strbuf_release(&amp;quickref);
        	}
        }
        static int print_one_push_status(struct ref *ref, const char *dest, int count,
        				 int porcelain, int summary_width)
        {
        	if (!count) {
        		char *url = transport_anonymize_url(dest);
        		fprintf(porcelain ? stdout : stderr, "To %s\n", url);
        		free(url);
        	}
        	switch(ref-&gt;status) {
        	case REF_STATUS_NONE:
        		print_ref_status('X', "[no match]", ref, NULL, NULL,
        				 porcelain, summary_width);
        		break;
        	case REF_STATUS_REJECT_NODELETE:
        		print_ref_status('!', "[rejected]", ref, NULL,
        				 "remote does not support deleting refs",
        				 porcelain, summary_width);
        		break;
        	case REF_STATUS_UPTODATE:
        		print_ref_status('=', "[up to date]", ref,
        				 ref-&gt;peer_ref, NULL, porcelain, summary_width);
        		break;
        	case REF_STATUS_REJECT_NONFASTFORWARD:
        		print_ref_status('!', "[rejected]", ref, ref-&gt;peer_ref,
        				 "non-fast-forward", porcelain, summary_width);
        		break;
        	case REF_STATUS_REJECT_ALREADY_EXISTS:
        		print_ref_status('!', "[rejected]", ref, ref-&gt;peer_ref,
        				 "already exists", porcelain, summary_width);
        		break;
        	case REF_STATUS_REJECT_FETCH_FIRST:
        		print_ref_status('!', "[rejected]", ref, ref-&gt;peer_ref,
        				 "fetch first", porcelain, summary_width);
        		break;
        	case REF_STATUS_REJECT_NEEDS_FORCE:
        		print_ref_status('!', "[rejected]", ref, ref-&gt;peer_ref,
        				 "needs force", porcelain, summary_width);
        		break;
        	case REF_STATUS_REJECT_STALE:
        		print_ref_status('!', "[rejected]", ref, ref-&gt;peer_ref,
        				 "stale info", porcelain, summary_width);
        		break;
        	case REF_STATUS_REJECT_SHALLOW:
        		print_ref_status('!', "[rejected]", ref, ref-&gt;peer_ref,
        				 "new shallow roots not allowed",
        				 porcelain, summary_width);
        		break;
        	case REF_STATUS_REMOTE_REJECT:
        		print_ref_status('!', "[remote rejected]", ref,
        				 ref-&gt;deletion ? NULL : ref-&gt;peer_ref,
        				 ref-&gt;remote_status, porcelain, summary_width);
        		break;
        	case REF_STATUS_EXPECTING_REPORT:
        		print_ref_status('!', "[remote failure]", ref,
        				 ref-&gt;deletion ? NULL : ref-&gt;peer_ref,
        				 "remote failed to report status",
        				 porcelain, summary_width);
        		break;
        	case REF_STATUS_ATOMIC_PUSH_FAILED:
        		print_ref_status('!', "[rejected]", ref, ref-&gt;peer_ref,
        				 "atomic push failed", porcelain, summary_width);
        		break;
        	case REF_STATUS_OK:
        		print_ok_ref_status(ref, porcelain, summary_width);
        		break;
        	}
        	return 1;
        }
        static int measure_abbrev(const struct object_id *oid, int sofar)
        {
        	char hex[GIT_MAX_HEXSZ + 1];
        	int w = find_unique_abbrev_r(hex, oid, DEFAULT_ABBREV);
        	return (w &lt; sofar) ? sofar : w;
        }
        int transport_summary_width(const struct ref *refs)
        {
        	int maxw = -1;
        	for (; refs; refs = refs-&gt;next) {
        		maxw = measure_abbrev(&amp;refs-&gt;old_oid, maxw);
        		maxw = measure_abbrev(&amp;refs-&gt;new_oid, maxw);
        	}
        	if (maxw &lt; 0)
        		maxw = FALLBACK_DEFAULT_ABBREV;
        	return (2 * maxw + 3);
        }
        void transport_print_push_status(const char *dest, struct ref *refs,
        				  int verbose, int porcelain, unsigned int *reject_reasons)
        {
        	struct ref *ref;
        	int n = 0;
        	char *head;
        	int summary_width = transport_summary_width(refs);
        	if (transport_color_config() &lt; 0)
        		warning(_("could not parse transport.color.* config"));
        	head = resolve_refdup("HEAD", RESOLVE_REF_READING, NULL, NULL);
        	if (verbose) {
        		for (ref = refs; ref; ref = ref-&gt;next)
        			if (ref-&gt;status == REF_STATUS_UPTODATE)
        				n += print_one_push_status(ref, dest, n,
        							   porcelain, summary_width);
        	}
        	for (ref = refs; ref; ref = ref-&gt;next)
        		if (ref-&gt;status == REF_STATUS_OK)
        			n += print_one_push_status(ref, dest, n,
        						   porcelain, summary_width);
        	*reject_reasons = 0;
        	for (ref = refs; ref; ref = ref-&gt;next) {
        		if (ref-&gt;status != REF_STATUS_NONE &amp;&amp;
        		    ref-&gt;status != REF_STATUS_UPTODATE &amp;&amp;
        		    ref-&gt;status != REF_STATUS_OK)
        			n += print_one_push_status(ref, dest, n,
        						   porcelain, summary_width);
        		if (ref-&gt;status == REF_STATUS_REJECT_NONFASTFORWARD) {
        			if (head != NULL &amp;&amp; !strcmp(head, ref-&gt;name))
        				*reject_reasons |= REJECT_NON_FF_HEAD;
        			else
        				*reject_reasons |= REJECT_NON_FF_OTHER;
        		} else if (ref-&gt;status == REF_STATUS_REJECT_ALREADY_EXISTS) {
        			*reject_reasons |= REJECT_ALREADY_EXISTS;
        		} else if (ref-&gt;status == REF_STATUS_REJECT_FETCH_FIRST) {
        			*reject_reasons |= REJECT_FETCH_FIRST;
        		} else if (ref-&gt;status == REF_STATUS_REJECT_NEEDS_FORCE) {
        			*reject_reasons |= REJECT_NEEDS_FORCE;
        		}
        	}
        	free(head);
        }
        static int git_transport_push(struct transport *transport, struct ref *remote_refs, int flags)
        {
        	struct git_transport_data *data = transport-&gt;data;
        	struct send_pack_args args;
        	int ret = 0;
        	if (transport_color_config() &lt; 0)
        		return -1;
        	if (!data-&gt;got_remote_heads)
        		get_refs_via_connect(transport, 1, NULL);
        	memset(&amp;args, 0, sizeof(args));
        	args.send_mirror = !!(flags &amp; TRANSPORT_PUSH_MIRROR);
        	args.force_update = !!(flags &amp; TRANSPORT_PUSH_FORCE);
        	args.use_thin_pack = data-&gt;options.thin;
        	args.verbose = (transport-&gt;verbose &gt; 0);
        	args.quiet = (transport-&gt;verbose &lt; 0);
        	args.progress = transport-&gt;progress;
        	args.dry_run = !!(flags &amp; TRANSPORT_PUSH_DRY_RUN);
        	args.porcelain = !!(flags &amp; TRANSPORT_PUSH_PORCELAIN);
        	args.atomic = !!(flags &amp; TRANSPORT_PUSH_ATOMIC);
        	args.push_options = transport-&gt;push_options;
        	args.url = transport-&gt;url;
        	if (flags &amp; TRANSPORT_PUSH_CERT_ALWAYS)
        		args.push_cert = SEND_PACK_PUSH_CERT_ALWAYS;
        	else if (flags &amp; TRANSPORT_PUSH_CERT_IF_ASKED)
        		args.push_cert = SEND_PACK_PUSH_CERT_IF_ASKED;
        	else
        		args.push_cert = SEND_PACK_PUSH_CERT_NEVER;
        	switch (data-&gt;version) {
        	case protocol_v2:
        		die(_("support for protocol v2 not implemented yet"));
        		break;
        	case protocol_v1:
        	case protocol_v0:
        		ret = send_pack(&amp;args, data-&gt;fd, data-&gt;conn, remote_refs,
        				&amp;data-&gt;extra_have);
        		break;
        	case protocol_unknown_version:
        		BUG("unknown protocol version");
        	}
        	close(data-&gt;fd[1]);
        	close(data-&gt;fd[0]);
        	ret |= finish_connect(data-&gt;conn);
        	data-&gt;conn = NULL;
        	data-&gt;got_remote_heads = 0;
        	return ret;
        }
        static int connect_git(struct transport *transport, const char *name,
        		       const char *executable, int fd[2])
        {
        	struct git_transport_data *data = transport-&gt;data;
        	data-&gt;conn = git_connect(data-&gt;fd, transport-&gt;url,
        				 executable, 0);
        	fd[0] = data-&gt;fd[0];
        	fd[1] = data-&gt;fd[1];
        	return 0;
        }
        static int disconnect_git(struct transport *transport)
        {
        	struct git_transport_data *data = transport-&gt;data;
        	if (data-&gt;conn) {
        		if (data-&gt;got_remote_heads)
        			packet_flush(data-&gt;fd[1]);
        		close(data-&gt;fd[0]);
        		close(data-&gt;fd[1]);
        		finish_connect(data-&gt;conn);
        	}
        	free(data);
        	return 0;
        }
        static struct transport_vtable taken_over_vtable = {
        	1,
        	NULL,
        	get_refs_via_connect,
        	fetch_refs_via_pack,
        	git_transport_push,
        	NULL,
        	disconnect_git
        };
        void transport_take_over(struct transport *transport,
        			 struct child_process *child)
        {
        	struct git_transport_data *data;
        	if (!transport-&gt;smart_options)
        		BUG("taking over transport requires non-NULL "
        		    "smart_options field.");
        	data = xcalloc(1, sizeof(*data));
        	data-&gt;options = *transport-&gt;smart_options;
        	data-&gt;conn = child;
        	data-&gt;fd[0] = data-&gt;conn-&gt;out;
        	data-&gt;fd[1] = data-&gt;conn-&gt;in;
        	data-&gt;got_remote_heads = 0;
        	transport-&gt;data = data;
        	transport-&gt;vtable = &amp;taken_over_vtable;
        	transport-&gt;smart_options = &amp;(data-&gt;options);
        	transport-&gt;cannot_reuse = 1;
        }
        static int is_file(const char *url)
        {
        	struct stat buf;
        	if (stat(url, &amp;buf))
        		return 0;
        	return S_ISREG(buf.st_mode);
        }
        static int external_specification_len(const char *url)
        {
        	return strchr(url, ':') - url;
        }
        static const struct string_list *protocol_whitelist(void)
        {
        	static int enabled = -1;
        	static struct string_list allowed = STRING_LIST_INIT_DUP;
        	if (enabled &lt; 0) {
        		const char *v = getenv("GIT_ALLOW_PROTOCOL");
        		if (v) {
        			string_list_split(&amp;allowed, v, ':', -1);
        			string_list_sort(&amp;allowed);
        			enabled = 1;
        		} else {
        			enabled = 0;
        		}
        	}
        	return enabled ? &amp;allowed : NULL;
        }
        enum protocol_allow_config {
        	PROTOCOL_ALLOW_NEVER = 0,
        	PROTOCOL_ALLOW_USER_ONLY,
        	PROTOCOL_ALLOW_ALWAYS
        };
        static enum protocol_allow_config parse_protocol_config(const char *key,
        							const char *value)
        {
        	if (!strcasecmp(value, "always"))
        		return PROTOCOL_ALLOW_ALWAYS;
        	else if (!strcasecmp(value, "never"))
        		return PROTOCOL_ALLOW_NEVER;
        	else if (!strcasecmp(value, "user"))
        		return PROTOCOL_ALLOW_USER_ONLY;
        	die(_("unknown value for config '%s': %s"), key, value);
        }
        static enum protocol_allow_config get_protocol_config(const char *type)
        {
        	char *key = xstrfmt("protocol.%s.allow", type);
        	char *value;
        	/* first check the per-protocol config */
        	if (!git_config_get_string(key, &amp;value)) {
        		enum protocol_allow_config ret =
        			parse_protocol_config(key, value);
        		free(key);
        		free(value);
        		return ret;
        	}
        	free(key);
        	/* if defined, fallback to user-defined default for unknown protocols */
        	if (!git_config_get_string("protocol.allow", &amp;value)) {
        		enum protocol_allow_config ret =
        			parse_protocol_config("protocol.allow", value);
        		free(value);
        		return ret;
        	}
        	/* fallback to built-in defaults */
        	/* known safe */
        	if (!strcmp(type, "http") ||
        	    !strcmp(type, "https") ||
        	    !strcmp(type, "git") ||
        	    !strcmp(type, "ssh") ||
        	    !strcmp(type, "file"))
        		return PROTOCOL_ALLOW_ALWAYS;
        	/* known scary; err on the side of caution */
        	if (!strcmp(type, "ext"))
        		return PROTOCOL_ALLOW_NEVER;
        	/* unknown; by default let them be used only directly by the user */
        	return PROTOCOL_ALLOW_USER_ONLY;
        }
        int is_transport_allowed(const char *type, int from_user)
        {
        	const struct string_list *whitelist = protocol_whitelist();
        	if (whitelist)
        		return string_list_has_string(whitelist, type);
        	switch (get_protocol_config(type)) {
        	case PROTOCOL_ALLOW_ALWAYS:
        		return 1;
        	case PROTOCOL_ALLOW_NEVER:
        		return 0;
        	case PROTOCOL_ALLOW_USER_ONLY:
        		if (from_user &lt; 0)
        			from_user = git_env_bool("GIT_PROTOCOL_FROM_USER", 1);
        		return from_user;
        	}
        	BUG("invalid protocol_allow_config type");
        }
        void transport_check_allowed(const char *type)
        {
        	if (!is_transport_allowed(type, -1))
        		die(_("transport '%s' not allowed"), type);
        }
        static struct transport_vtable bundle_vtable = {
        	0,
        	NULL,
        	get_refs_from_bundle,
        	fetch_refs_from_bundle,
        	NULL,
        	NULL,
        	close_bundle
        };
        static struct transport_vtable builtin_smart_vtable = {
        	1,
        	NULL,
        	get_refs_via_connect,
        	fetch_refs_via_pack,
        	git_transport_push,
        	connect_git,
        	disconnect_git
        };
        struct transport *transport_get(struct remote *remote, const char *url)
        {
        	const char *helper;
        	struct transport *ret = xcalloc(1, sizeof(*ret));
        	ret-&gt;progress = isatty(2);
        	if (!remote)
        		BUG("No remote provided to transport_get()");
        	ret-&gt;got_remote_refs = 0;
        	ret-&gt;remote = remote;
        	helper = remote-&gt;foreign_vcs;
        	if (!url &amp;&amp; remote-&gt;url)
        		url = remote-&gt;url[0];
        	ret-&gt;url = url;
        	/* maybe it is a foreign URL? */
        	if (url) {
        		const char *p = url;
        		while (is_urlschemechar(p == url, *p))
        			p++;
        		if (starts_with(p, "::"))
        			helper = xstrndup(url, p - url);
        	}
        	if (helper) {
        		transport_helper_init(ret, helper);
        	} else if (starts_with(url, "rsync:")) {
        		die(_("git-over-rsync is no longer supported"));
        	} else if (url_is_local_not_ssh(url) &amp;&amp; is_file(url) &amp;&amp; is_bundle(url, 1)) {
        		struct bundle_transport_data *data = xcalloc(1, sizeof(*data));
        		transport_check_allowed("file");
        		ret-&gt;data = data;
        		ret-&gt;vtable = &amp;bundle_vtable;
        		ret-&gt;smart_options = NULL;
        	} else if (!is_url(url)
        		|| starts_with(url, "file://")
        		|| starts_with(url, "git://")
        		|| starts_with(url, "ssh://")
        		|| starts_with(url, "git+ssh://") /* deprecated - do not use */
        		|| starts_with(url, "ssh+git://") /* deprecated - do not use */
        		) {
        		/*
        		 * These are builtin smart transports; "allowed" transports
        		 * will be checked individually in git_connect.
        		 */
        		struct git_transport_data *data = xcalloc(1, sizeof(*data));
        		ret-&gt;data = data;
        		ret-&gt;vtable = &amp;builtin_smart_vtable;
        		ret-&gt;smart_options = &amp;(data-&gt;options);
        		data-&gt;conn = NULL;
        		data-&gt;got_remote_heads = 0;
        	} else {
        		/* Unknown protocol in URL. Pass to external handler. */
        		int len = external_specification_len(url);
        		char *handler = xmemdupz(url, len);
        		transport_helper_init(ret, handler);
        	}
        	if (ret-&gt;smart_options) {
        		ret-&gt;smart_options-&gt;thin = 1;
        		ret-&gt;smart_options-&gt;uploadpack = "git-upload-pack";
        		if (remote-&gt;uploadpack)
        			ret-&gt;smart_options-&gt;uploadpack = remote-&gt;uploadpack;
        		ret-&gt;smart_options-&gt;receivepack = "git-receive-pack";
        		if (remote-&gt;receivepack)
        			ret-&gt;smart_options-&gt;receivepack = remote-&gt;receivepack;
        	}
        	return ret;
        }
        int transport_set_option(struct transport *transport,
        			 const char *name, const char *value)
        {
        	int git_reports = 1, protocol_reports = 1;
        	if (transport-&gt;smart_options)
        		git_reports = set_git_option(transport-&gt;smart_options,
        					     name, value);
        	if (transport-&gt;vtable-&gt;set_option)
        		protocol_reports = transport-&gt;vtable-&gt;set_option(transport,
        								 name, value);
        	/* If either report is 0, report 0 (success). */
        	if (!git_reports || !protocol_reports)
        		return 0;
        	/* If either reports -1 (invalid value), report -1. */
        	if ((git_reports == -1) || (protocol_reports == -1))
        		return -1;
        	/* Otherwise if both report unknown, report unknown. */
        	return 1;
        }
        void transport_set_verbosity(struct transport *transport, int verbosity,
        	int force_progress)
        {
        	if (verbosity &gt;= 1)
        		transport-&gt;verbose = verbosity &lt;= 3 ? verbosity : 3;
        	if (verbosity &lt; 0)
        		transport-&gt;verbose = -1;
        	/**
        	 * Rules used to determine whether to report progress (processing aborts
        	 * when a rule is satisfied):
        	 *
        	 *   . Report progress, if force_progress is 1 (ie. --progress).
        	 *   . Don't report progress, if force_progress is 0 (ie. --no-progress).
        	 *   . Don't report progress, if verbosity &lt; 0 (ie. -q/--quiet ).
        	 *   . Report progress if isatty(2) is 1.
        	 **/
        	if (force_progress &gt;= 0)
        		transport-&gt;progress = !!force_progress;
        	else
        		transport-&gt;progress = verbosity &gt;= 0 &amp;&amp; isatty(2);
        }
        static void die_with_unpushed_submodules(struct string_list *needs_pushing)
        {
        	int i;
        	fprintf(stderr, _("The following submodule paths contain changes that can\n"
        			"not be found on any remote:\n"));
        	for (i = 0; i &lt; needs_pushing-&gt;nr; i++)
        		fprintf(stderr, "  %s\n", needs_pushing-&gt;items[i].string);
        	fprintf(stderr, _("\nPlease try\n\n"
        			  "	git push --recurse-submodules=on-demand\n\n"
        			  "or cd to the path and use\n\n"
        			  "	git push\n\n"
        			  "to push them to a remote.\n\n"));
        	string_list_clear(needs_pushing, 0);
        	die(_("Aborting."));
        }
        static int run_pre_push_hook(struct transport *transport,
        			     struct ref *remote_refs)
        {
        	int ret = 0, x;
        	struct ref *r;
        	struct child_process proc = CHILD_PROCESS_INIT;
        	struct strbuf buf;
        	const char *argv[4];
        	if (!(argv[0] = find_hook("pre-push")))
        		return 0;
        	argv[1] = transport-&gt;remote-&gt;name;
        	argv[2] = transport-&gt;url;
        	argv[3] = NULL;
        	proc.argv = argv;
        	proc.in = -1;
        	proc.trace2_hook_name = "pre-push";
        	if (start_command(&amp;proc)) {
        		finish_command(&amp;proc);
        		return -1;
        	}
        	sigchain_push(SIGPIPE, SIG_IGN);
        	strbuf_init(&amp;buf, 256);
        	for (r = remote_refs; r; r = r-&gt;next) {
        		if (!r-&gt;peer_ref) continue;
        		if (r-&gt;status == REF_STATUS_REJECT_NONFASTFORWARD) continue;
        		if (r-&gt;status == REF_STATUS_REJECT_STALE) continue;
        		if (r-&gt;status == REF_STATUS_UPTODATE) continue;
        		strbuf_reset(&amp;buf);
        		strbuf_addf( &amp;buf, "%s %s %s %s\n",
        			 r-&gt;peer_ref-&gt;name, oid_to_hex(&amp;r-&gt;new_oid),
        			 r-&gt;name, oid_to_hex(&amp;r-&gt;old_oid));
        		if (write_in_full(proc.in, buf.buf, buf.len) &lt; 0) {
        			/* We do not mind if a hook does not read all refs. */
        			if (errno != EPIPE)
        				ret = -1;
        			break;
        		}
        	}
        	strbuf_release(&amp;buf);
        	x = close(proc.in);
        	if (!ret)
        		ret = x;
        	sigchain_pop(SIGPIPE);
        	x = finish_command(&amp;proc);
        	if (!ret)
        		ret = x;
        	return ret;
        }
        int transport_push(struct repository *r,
        		   struct transport *transport,
        		   struct refspec *rs, int flags,
        		   unsigned int *reject_reasons)
        {
        	*reject_reasons = 0;
        	if (transport_color_config() &lt; 0)
        		return -1;
        	if (transport-&gt;vtable-&gt;push_refs) {
        		struct ref *remote_refs;
        		struct ref *local_refs = get_local_heads();
        		int match_flags = MATCH_REFS_NONE;
        		int verbose = (transport-&gt;verbose &gt; 0);
        		int quiet = (transport-&gt;verbose &lt; 0);
        		int porcelain = flags &amp; TRANSPORT_PUSH_PORCELAIN;
        		int pretend = flags &amp; TRANSPORT_PUSH_DRY_RUN;
        		int push_ret, ret, err;
        		struct argv_array ref_prefixes = ARGV_ARRAY_INIT;
        		if (check_push_refs(local_refs, rs) &lt; 0)
        			return -1;
        		refspec_ref_prefixes(rs, &amp;ref_prefixes);
        		remote_refs = transport-&gt;vtable-&gt;get_refs_list(transport, 1,
        							       &amp;ref_prefixes);
        		argv_array_clear(&amp;ref_prefixes);
        		if (flags &amp; TRANSPORT_PUSH_ALL)
        			match_flags |= MATCH_REFS_ALL;
        		if (flags &amp; TRANSPORT_PUSH_MIRROR)
        			match_flags |= MATCH_REFS_MIRROR;
        		if (flags &amp; TRANSPORT_PUSH_PRUNE)
        			match_flags |= MATCH_REFS_PRUNE;
        		if (flags &amp; TRANSPORT_PUSH_FOLLOW_TAGS)
        			match_flags |= MATCH_REFS_FOLLOW_TAGS;
        		if (match_push_refs(local_refs, &amp;remote_refs, rs, match_flags))
        			return -1;
        		if (transport-&gt;smart_options &amp;&amp;
        		    transport-&gt;smart_options-&gt;cas &amp;&amp;
        		    !is_empty_cas(transport-&gt;smart_options-&gt;cas))
        			apply_push_cas(transport-&gt;smart_options-&gt;cas,
        				       transport-&gt;remote, remote_refs);
        		set_ref_status_for_push(remote_refs,
        			flags &amp; TRANSPORT_PUSH_MIRROR,
        			flags &amp; TRANSPORT_PUSH_FORCE);
        		if (!(flags &amp; TRANSPORT_PUSH_NO_HOOK))
        			if (run_pre_push_hook(transport, remote_refs))
        				return -1;
        		if ((flags &amp; (TRANSPORT_RECURSE_SUBMODULES_ON_DEMAND |
        			      TRANSPORT_RECURSE_SUBMODULES_ONLY)) &amp;&amp;
        		    !is_bare_repository()) {
        			struct ref *ref = remote_refs;
        			struct oid_array commits = OID_ARRAY_INIT;
        			for (; ref; ref = ref-&gt;next)
        				if (!is_null_oid(&amp;ref-&gt;new_oid))
        					oid_array_append(&amp;commits,
        							  &amp;ref-&gt;new_oid);
        			if (!push_unpushed_submodules(r,
        						      &amp;commits,
        						      transport-&gt;remote,
        						      rs,
        						      transport-&gt;push_options,
        						      pretend)) {
        				oid_array_clear(&amp;commits);
        				die(_("failed to push all needed submodules"));
        			}
        			oid_array_clear(&amp;commits);
        		}
        		if (((flags &amp; TRANSPORT_RECURSE_SUBMODULES_CHECK) ||
        		     ((flags &amp; (TRANSPORT_RECURSE_SUBMODULES_ON_DEMAND |
        				TRANSPORT_RECURSE_SUBMODULES_ONLY)) &amp;&amp;
        		      !pretend)) &amp;&amp; !is_bare_repository()) {
        			struct ref *ref = remote_refs;
        			struct string_list needs_pushing = STRING_LIST_INIT_DUP;
        			struct oid_array commits = OID_ARRAY_INIT;
        			for (; ref; ref = ref-&gt;next)
        				if (!is_null_oid(&amp;ref-&gt;new_oid))
        					oid_array_append(&amp;commits,
        							  &amp;ref-&gt;new_oid);
        			if (find_unpushed_submodules(r,
        						     &amp;commits,
        						     transport-&gt;remote-&gt;name,
        						     &amp;needs_pushing)) {
        				oid_array_clear(&amp;commits);
        				die_with_unpushed_submodules(&amp;needs_pushing);
        			}
        			string_list_clear(&amp;needs_pushing, 0);
        			oid_array_clear(&amp;commits);
        		}
        		if (!(flags &amp; TRANSPORT_RECURSE_SUBMODULES_ONLY))
        			push_ret = transport-&gt;vtable-&gt;push_refs(transport, remote_refs, flags);
        		else
        			push_ret = 0;
        		err = push_had_errors(remote_refs);
        		ret = push_ret | err;
        		if ((flags &amp; TRANSPORT_PUSH_ATOMIC) &amp;&amp; err) {
        			struct ref *it;
        			for (it = remote_refs; it; it = it-&gt;next)
        				switch (it-&gt;status) {
        				case REF_STATUS_NONE:
        				case REF_STATUS_UPTODATE:
        				case REF_STATUS_OK:
        					it-&gt;status = REF_STATUS_ATOMIC_PUSH_FAILED;
        					break;
        				default:
        					break;
        				}
        		}
        		if (!quiet || err)
        			transport_print_push_status(transport-&gt;url, remote_refs,
        					verbose | porcelain, porcelain,
        					reject_reasons);
        		if (flags &amp; TRANSPORT_PUSH_SET_UPSTREAM)
        			set_upstreams(transport, remote_refs, pretend);
        		if (!(flags &amp; (TRANSPORT_PUSH_DRY_RUN |
        			       TRANSPORT_RECURSE_SUBMODULES_ONLY))) {
        			struct ref *ref;
        			for (ref = remote_refs; ref; ref = ref-&gt;next)
        				transport_update_tracking_ref(transport-&gt;remote, ref, verbose);
        		}
        		if (porcelain &amp;&amp; !push_ret)
        			puts("Done");
        		else if (!quiet &amp;&amp; !ret &amp;&amp; !transport_refs_pushed(remote_refs))
        			fprintf(stderr, "Everything up-to-date\n");
        		return ret;
        	}
        	return 1;
        }
        const struct ref *transport_get_remote_refs(struct transport *transport,
        					    const struct argv_array *ref_prefixes)
        {
        	if (!transport-&gt;got_remote_refs) {
        		transport-&gt;remote_refs =
        			transport-&gt;vtable-&gt;get_refs_list(transport, 0,
        							 ref_prefixes);
        		transport-&gt;got_remote_refs = 1;
        	}
        	return transport-&gt;remote_refs;
        }
        int transport_fetch_refs(struct transport *transport, struct ref *refs)
        {
        	int rc;
        	int nr_heads = 0, nr_alloc = 0, nr_refs = 0;
        	struct ref **heads = NULL;
        	struct ref *rm;
        	if (!transport-&gt;vtable-&gt;fetch_without_list)
        		/*
        		 * Some transports (e.g. the built-in bundle transport and the
        		 * transport helper interface) do not work when fetching is
        		 * done immediately after transport creation. List the remote
        		 * refs anyway (if not already listed) as a workaround.
        		 */
        		transport_get_remote_refs(transport, NULL);
        	for (rm = refs; rm; rm = rm-&gt;next) {
        		nr_refs++;
        		if (rm-&gt;peer_ref &amp;&amp;
        		    !is_null_oid(&amp;rm-&gt;old_oid) &amp;&amp;
        		    oideq(&amp;rm-&gt;peer_ref-&gt;old_oid, &amp;rm-&gt;old_oid))
        			continue;
        		ALLOC_GROW(heads, nr_heads + 1, nr_alloc);
        		heads[nr_heads++] = rm;
        	}
        	if (!nr_heads) {
        		/*
        		 * When deepening of a shallow repository is requested,
        		 * then local and remote refs are likely to still be equal.
        		 * Just feed them all to the fetch method in that case.
        		 * This condition shouldn't be met in a non-deepening fetch
        		 * (see builtin/fetch.c:quickfetch()).
        		 */
        		ALLOC_ARRAY(heads, nr_refs);
        		for (rm = refs; rm; rm = rm-&gt;next)
        			heads[nr_heads++] = rm;
        	}
        	rc = transport-&gt;vtable-&gt;fetch(transport, nr_heads, heads);
        	free(heads);
        	return rc;
        }
        void transport_unlock_pack(struct transport *transport)
        {
        	if (transport-&gt;pack_lockfile) {
        		unlink_or_warn(transport-&gt;pack_lockfile);
        		FREE_AND_NULL(transport-&gt;pack_lockfile);
        	}
        }
        int transport_connect(struct transport *transport, const char *name,
        		      const char *exec, int fd[2])
        {
        	if (transport-&gt;vtable-&gt;connect)
        		return transport-&gt;vtable-&gt;connect(transport, name, exec, fd);
        	else
        		die(_("operation not supported by protocol"));
        }
        int transport_disconnect(struct transport *transport)
        {
        	int ret = 0;
        	if (transport-&gt;vtable-&gt;disconnect)
        		ret = transport-&gt;vtable-&gt;disconnect(transport);
        	free(transport);
        	return ret;
        }
        /*
         * Strip username (and password) from a URL and return
         * it in a newly allocated string.
         */
        char *transport_anonymize_url(const char *url)
        {
        	char *scheme_prefix, *anon_part;
        	size_t anon_len, prefix_len = 0;
        	anon_part = strchr(url, '@');
        	if (url_is_local_not_ssh(url) || !anon_part)
        		goto literal_copy;
        	anon_len = strlen(++anon_part);
        	scheme_prefix = strstr(url, "://");
        	if (!scheme_prefix) {
        		if (!strchr(anon_part, ':'))
        			/* cannot be "me@there:/path/name" */
        			goto literal_copy;
        	} else {
        		const char *cp;
        		/* make sure scheme is reasonable */
        		for (cp = url; cp &lt; scheme_prefix; cp++) {
        			switch (*cp) {
        				/* RFC 1738 2.1 */
        			case '+': case '.': case '-':
        				break; /* ok */
        			default:
        				if (isalnum(*cp))
        					break;
        				/* it isn't */
        				goto literal_copy;
        			}
        		}
        		/* @ past the first slash does not count */
        		cp = strchr(scheme_prefix + 3, '/');
        		if (cp &amp;&amp; cp &lt; anon_part)
        			goto literal_copy;
        		prefix_len = scheme_prefix - url + 3;
        	}
        	return xstrfmt("%.*s%.*s", (int)prefix_len, url,
        		       (int)anon_len, anon_part);
        literal_copy:
        	return xstrdup(url);
        }
            Copy lines
            Copy permalink
        View git blame
       -->
        Go
        © 2020 GitHub, Inc.
          Terms
          Privacy
  Cookie Preferences
          Security
          Status
          Help
          Contact GitHub
          Pricing
        API
        Training
          Blog
          About
    You can’t perform that action at this time.
    You signed in with another tab or window. Reload to refresh your session.
    You signed out in another tab or window. Reload to refresh your session.
  We use optional third-party analytics cookies to understand how you use GitHub.com so we can build better products.
              Learn more.
              Accept
              Reject
  We use optional third-party analytics cookies to understand how you use GitHub.com so we can build better products.
              You can always update your selection by clicking Cookie Preferences at the bottom of the page.
              For more information, see our Privacy Statement.
              Essential cookies
              We use essential cookies to perform essential website functions, e.g. they're used to log you in. 
                Learn more
              Always active
              Analytics cookies
              We use analytics cookies to understand how you use our websites so we can make them better, e.g. they're used to gather information about the pages you visit and how many clicks you need to accomplish a task. 
                Learn more
                Accept
                Reject
            Save preferences
