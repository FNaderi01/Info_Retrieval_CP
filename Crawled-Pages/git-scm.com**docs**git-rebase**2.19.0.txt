        About
            Branching and Merging
            Small and Fast
            Distributed
            Data Assurance
            Staging Area
            Free and Open Source
            Trademark
        Documentation
            Reference
            Book
            Videos
            External Links
        Downloads
            GUI Clients
            Logos
        Community
  English ▾
  Localized versions of git-rebase manual
        English
        Português (Brasil)
    Want to read in your language or fix typos? You can help translate this page.
    Topics ▾
      Setup and Config
  git
  config
  help
  bugreport
      Getting and Creating Projects
  init
  clone
      Basic Snapshotting
  add
  status
  diff
  commit
  notes
  restore
  reset
  rm
  mv
      Branching and Merging
  branch
  checkout
  switch
  merge
  mergetool
  log
  stash
  tag
  worktree
      Sharing and Updating Projects
  fetch
  pull
  push
  remote
  submodule
      Inspection and Comparison
  show
  log
  diff
  difftool
  range-diff
  shortlog
  describe
      Patching
  apply
  cherry-pick
  diff
  rebase
  revert
      Debugging
  bisect
  blame
  grep
      Email
  am
  apply
  format-patch
  send-email
  request-pull
      External Systems
  svn
  fast-import
      Server Admin
  daemon
  update-server-info
      Guides
  gitattributes
  Command-line interface conventions
  Everyday Git
  Frequently Asked Questions (FAQ)
  Glossary
  githooks
  gitignore
  gitmodules
  Revisions
  Submodules
  Tutorial
  Workflows
      Administration
  clean
  gc
  fsck
  reflog
  filter-branch
  instaweb
  archive
  bundle
      Plumbing Commands
  cat-file
  check-ignore
  checkout-index
  commit-tree
  count-objects
  diff-index
  for-each-ref
  hash-object
  ls-files
  ls-tree
  merge-base
  read-tree
  rev-list
  rev-parse
  show-ref
  symbolic-ref
  update-index
  update-ref
  verify-pack
  write-tree
    Version 2.19.0
 ▾ 
git-rebase last updated in 2.28.0
  Changes in the git-rebase manual
        2.28.0
          07/27/20
        2.27.0
          06/01/20
        2.26.1 → 2.26.2 no changes
        2.26.0
          03/22/20
        2.25.1 → 2.25.4 no changes
        2.25.0
          01/13/20
        2.24.1 → 2.24.3 no changes
        2.24.0
          11/04/19
        2.23.1 → 2.23.3 no changes
        2.23.0
          08/16/19
        2.22.1 → 2.22.4 no changes
        2.22.0
          06/07/19
        2.21.1 → 2.21.3 no changes
        2.21.0
          02/24/19
        2.20.1 → 2.20.4 no changes
        2.20.0
          12/09/18
        2.19.3 → 2.19.5 no changes
        2.19.2
          11/21/18
        2.19.1 no changes
        2.19.0
          09/10/18
        2.18.1 → 2.18.4 no changes
        2.18.0
          06/21/18
        2.17.1 → 2.17.5 no changes
        2.17.0
          04/02/18
        2.16.6
          12/06/19
        2.15.4
          12/06/19
        2.14.6
          12/06/19
        2.13.7
          05/22/18
        2.12.5
          09/22/17
        2.10.5 → 2.11.4 no changes
        2.9.5
          07/30/17
        2.8.6
          07/30/17
        2.7.6 no changes
        2.6.7
          05/05/17
        2.5.6 no changes
        2.4.12
          05/05/17
        2.3.10
          09/28/15
        2.2.3
          09/04/15
        2.1.4
          12/17/14
    See more previous releases → -->
    Check your version of git by running
    $
NAME
git-rebase - Reapply commits on top of another base tip
SYNOPSIS
git rebase [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]
	[&lt;upstream&gt; [&lt;branch&gt;]]
git rebase [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]
	--root [&lt;branch&gt;]
git rebase --continue | --skip | --abort | --quit | --edit-todo | --show-current-patch
DESCRIPTION
If &lt;branch&gt; is specified, git rebase will perform an automatic
git checkout &lt;branch&gt; before doing anything else.  Otherwise
it remains on the current branch.
If &lt;upstream&gt; is not specified, the upstream configured in
branch.&lt;name&gt;.remote and branch.&lt;name&gt;.merge options will be used (see
git-config[1] for details) and the --fork-point option is
assumed.  If you are currently not on any branch or if the current
branch does not have a configured upstream, the rebase will abort.
All changes made by commits in the current branch but that are not
in &lt;upstream&gt; are saved to a temporary area.  This is the same set
of commits that would be shown by git log &lt;upstream&gt;..HEAD; or by
git log 'fork_point'..HEAD, if --fork-point is active (see the
description on --fork-point below); or by git log HEAD, if the
--root option is specified.
The current branch is reset to &lt;upstream&gt;, or &lt;newbase&gt; if the
--onto option was supplied.  This has the exact same effect as
git reset --hard &lt;upstream&gt; (or &lt;newbase&gt;).  ORIG_HEAD is set
to point at the tip of the branch before the reset.
The commits that were previously saved into the temporary area are
then reapplied to the current branch, one by one, in order. Note that
any commits in HEAD which introduce the same textual changes as a commit
in HEAD..&lt;upstream&gt; are omitted (i.e., a patch already accepted upstream
with a different commit message or timestamp will be skipped).
It is possible that a merge failure will prevent this process from being
completely automatic.  You will have to resolve any such merge failure
and run git rebase --continue.  Another option is to bypass the commit
that caused the merge failure with git rebase --skip.  To check out the
original &lt;branch&gt; and remove the .git/rebase-apply working files, use the
command git rebase --abort instead.
Assume the following history exists and the current branch is "topic":
          A---B---C topic
         /
    D---E---F---G master
From this point, the result of either of the following commands:
git rebase master
git rebase master topic
would be:
                  A'--B'--C' topic
                 /
    D---E---F---G master
NOTE: The latter form is just a short-hand of git checkout topic
followed by git rebase master. When rebase exits topic will
remain the checked-out branch.
If the upstream branch already contains a change you have made (e.g.,
because you mailed a patch which was applied upstream), then that commit
will be skipped. For example, running git rebase master on the
following history (in which A' and A introduce the same set of changes,
but have different committer information):
          A---B---C topic
         /
    D---E---A'---F master
will result in:
                   B'---C' topic
                  /
    D---E---A'---F master
Here is how you would transplant a topic branch based on one
branch to another, to pretend that you forked the topic branch
from the latter branch, using rebase --onto.
First let’s assume your topic is based on branch next.
For example, a feature developed in topic depends on some
functionality which is found in next.
    o---o---o---o---o  master
         \
          o---o---o---o---o  next
                           \
                            o---o---o  topic
We want to make topic forked from branch master; for example,
because the functionality on which topic depends was merged into the
more stable master branch. We want our tree to look like this:
    o---o---o---o---o  master
        |            \
        |             o'--o'--o'  topic
         \
          o---o---o---o---o  next
We can get this using the following command:
git rebase --onto master next topic
Another example of --onto option is to rebase part of a
branch.  If we have the following situation:
                            H---I---J topicB
                           /
                  E---F---G  topicA
                 /
    A---B---C---D  master
then the command
git rebase --onto master topicA topicB
would result in:
                 H'--I'--J'  topicB
                /
                | E---F---G  topicA
                |/
    A---B---C---D  master
This is useful when topicB does not depend on topicA.
A range of commits could also be removed with rebase.  If we have
the following situation:
    E---F---G---H---I---J  topicA
then the command
git rebase --onto topicA~5 topicA~3 topicA
would result in the removal of commits F and G:
    E---H'---I'---J'  topicA
This is useful if F and G were flawed in some way, or should not be
part of topicA.  Note that the argument to --onto and the &lt;upstream&gt;
parameter can be any valid commit-ish.
In case of conflict, git rebase will stop at the first problematic commit
and leave conflict markers in the tree.  You can use git diff to locate
the markers (&lt;&lt;&lt;&lt;&lt;&lt;) and make edits to resolve the conflict.  For each
file you edit, you need to tell Git that the conflict has been resolved,
typically this would be done with
git add &lt;filename&gt;
After resolving the conflict manually and updating the index with the
desired resolution, you can continue the rebasing process with
git rebase --continue
Alternatively, you can undo the git rebase with
git rebase --abort
CONFIGURATION
 rebase.stat 
Whether to show a diffstat of what changed upstream since the last
rebase. False by default.
 rebase.autoSquash 
If set to true enable --autosquash option by default.
 rebase.autoStash 
When set to true, automatically create a temporary stash entry
before the operation begins, and apply it after the operation
ends.  This means that you can run rebase on a dirty worktree.
However, use with care: the final stash application after a
successful rebase might result in non-trivial conflicts.
This option can be overridden by the --no-autostash and
--autostash options of git-rebase[1].
Defaults to false.
 rebase.missingCommitsCheck 
If set to "warn", git rebase -i will print a warning if some
commits are removed (e.g. a line was deleted), however the
rebase will still proceed. If set to "error", it will print
the previous warning and stop the rebase, git rebase
--edit-todo can then be used to correct the error. If set to
"ignore", no checking is done.
To drop a commit without warning or error, use the drop
command in the todo list.
Defaults to "ignore".
 rebase.instructionFormat 
A format string, as specified in git-log[1], to be used for the
todo list during an interactive rebase.  The format will
automatically have the long commit hash prepended to the format.
 rebase.abbreviateCommands 
If set to true, git rebase will use abbreviated command names in the
todo list resulting in something like this:
	p deadbee The oneline of the commit
	p fa1afe1 The oneline of the next commit
	...
instead of:
	pick deadbee The oneline of the commit
	pick fa1afe1 The oneline of the next commit
	...
Defaults to false.
OPTIONS
 --onto &lt;newbase&gt; 
Starting point at which to create the new commits. If the
--onto option is not specified, the starting point is
&lt;upstream&gt;.  May be any valid commit, and not just an
existing branch name.
As a special case, you may use "A...B" as a shortcut for the
merge base of A and B if there is exactly one merge base. You can
leave out at most one of A and B, in which case it defaults to HEAD.
 &lt;upstream&gt; 
Upstream branch to compare against.  May be any valid commit,
not just an existing branch name. Defaults to the configured
upstream for the current branch.
 &lt;branch&gt; 
Working branch; defaults to HEAD.
 --continue 
Restart the rebasing process after having resolved a merge conflict.
 --abort 
Abort the rebase operation and reset HEAD to the original
branch. If &lt;branch&gt; was provided when the rebase operation was
started, then HEAD will be reset to &lt;branch&gt;. Otherwise HEAD
will be reset to where it was when the rebase operation was
started.
 --quit 
Abort the rebase operation but HEAD is not reset back to the
original branch. The index and working tree are also left
unchanged as a result.
 --keep-empty 
Keep the commits that do not change anything from its
parents in the result.
See also INCOMPATIBLE OPTIONS below.
 --allow-empty-message 
By default, rebasing commits with an empty message will fail.
This option overrides that behavior, allowing commits with empty
messages to be rebased.
See also INCOMPATIBLE OPTIONS below.
 --skip 
Restart the rebasing process by skipping the current patch.
 --edit-todo 
Edit the todo list during an interactive rebase.
 --show-current-patch 
Show the current patch in an interactive rebase or when rebase
is stopped because of conflicts. This is the equivalent of
git show REBASE_HEAD.
 -m 
 --merge 
Use merging strategies to rebase.  When the recursive (default) merge
strategy is used, this allows rebase to be aware of renames on the
upstream side.
Note that a rebase merge works by replaying each commit from the working
branch on top of the &lt;upstream&gt; branch.  Because of this, when a merge
conflict happens, the side reported as ours is the so-far rebased
series, starting with &lt;upstream&gt;, and theirs is the working branch.  In
other words, the sides are swapped.
See also INCOMPATIBLE OPTIONS below.
 -s &lt;strategy&gt; 
 --strategy=&lt;strategy&gt; 
Use the given merge strategy.
If there is no -s option git merge-recursive is used
instead.  This implies --merge.
Because git rebase replays each commit from the working branch
on top of the &lt;upstream&gt; branch using the given strategy, using
the ours strategy simply empties all patches from the &lt;branch&gt;,
which makes little sense.
See also INCOMPATIBLE OPTIONS below.
 -X &lt;strategy-option&gt; 
 --strategy-option=&lt;strategy-option&gt; 
Pass the &lt;strategy-option&gt; through to the merge strategy.
This implies --merge and, if no strategy has been
specified, -s recursive.  Note the reversal of ours and
theirs as noted above for the -m option.
See also INCOMPATIBLE OPTIONS below.
 -S[&lt;keyid&gt;] 
 --gpg-sign[=&lt;keyid&gt;] 
GPG-sign commits. The keyid argument is optional and
defaults to the committer identity; if specified, it must be
stuck to the option without a space.
 -q 
 --quiet 
Be quiet. Implies --no-stat.
 -v 
 --verbose 
Be verbose. Implies --stat.
 --stat 
Show a diffstat of what changed upstream since the last rebase. The
diffstat is also controlled by the configuration option rebase.stat.
 -n 
 --no-stat 
Do not show a diffstat as part of the rebase process.
 --no-verify 
This option bypasses the pre-rebase hook.  See also githooks[5].
 --verify 
Allows the pre-rebase hook to run, which is the default.  This option can
be used to override --no-verify.  See also githooks[5].
 -C&lt;n&gt; 
Ensure at least &lt;n&gt; lines of surrounding context match before
and after each change.  When fewer lines of surrounding
context exist they all must match.  By default no context is
ever ignored.
See also INCOMPATIBLE OPTIONS below.
 --no-ff 
 --force-rebase 
 -f 
Individually replay all rebased commits instead of fast-forwarding
over the unchanged ones.  This ensures that the entire history of
the rebased branch is composed of new commits.
You may find this helpful after reverting a topic branch merge, as this option
recreates the topic branch with fresh commits so it can be remerged
successfully without needing to "revert the reversion" (see the
revert-a-faulty-merge How-To for
details).
 --fork-point 
 --no-fork-point 
Use reflog to find a better common ancestor between &lt;upstream&gt;
and &lt;branch&gt; when calculating which commits have been
introduced by &lt;branch&gt;.
When --fork-point is active, fork_point will be used instead of
&lt;upstream&gt; to calculate the set of commits to rebase, where
fork_point is the result of git merge-base --fork-point &lt;upstream&gt;
&lt;branch&gt; command (see git-merge-base[1]).  If fork_point
ends up being empty, the &lt;upstream&gt; will be used as a fallback.
If either &lt;upstream&gt; or --root is given on the command line, then the
default is --no-fork-point, otherwise the default is --fork-point.
 --ignore-whitespace 
 --whitespace=&lt;option&gt; 
These flag are passed to the git apply program
(see git-apply[1]) that applies the patch.
See also INCOMPATIBLE OPTIONS below.
 --committer-date-is-author-date 
 --ignore-date 
These flags are passed to git am to easily change the dates
of the rebased commits (see git-am[1]).
See also INCOMPATIBLE OPTIONS below.
 --signoff 
Add a Signed-off-by: trailer to all the rebased commits. Note
that if --interactive is given then only commits marked to be
picked, edited or reworded will have the trailer added.
See also INCOMPATIBLE OPTIONS below.
 -i 
 --interactive 
Make a list of the commits which are about to be rebased.  Let the
user edit that list before rebasing.  This mode can also be used to
split commits (see SPLITTING COMMITS below).
The commit list format can be changed by setting the configuration option
rebase.instructionFormat.  A customized instruction format will automatically
have the long commit hash prepended to the format.
See also INCOMPATIBLE OPTIONS below.
 -r 
 --rebase-merges[=(rebase-cousins|no-rebase-cousins)] 
By default, a rebase will simply drop merge commits from the todo
list, and put the rebased commits into a single, linear branch.
With --rebase-merges, the rebase will instead try to preserve
the branching structure within the commits that are to be rebased,
by recreating the merge commits. Any resolved merge conflicts or
manual amendments in these merge commits will have to be
resolved/re-applied manually.
By default, or when no-rebase-cousins was specified, commits which do not
have &lt;upstream&gt; as direct ancestor will keep their original branch point,
i.e. commits that would be excluded by git1's
--ancestry-path option will keep their original ancestry by default. If
the rebase-cousins mode is turned on, such commits are instead rebased
onto &lt;upstream&gt; (or &lt;onto&gt;, if specified).
The --rebase-merges mode is similar in spirit to --preserve-merges, but
in contrast to that option works well in interactive rebases: commits can be
reordered, inserted and dropped at will.
It is currently only possible to recreate the merge commits using the
recursive merge strategy; Different merge strategies can be used only via
explicit exec git merge -s &lt;strategy&gt; [...] commands.
See also REBASING MERGES and INCOMPATIBLE OPTIONS below.
 -p 
 --preserve-merges 
Recreate merge commits instead of flattening the history by replaying
commits a merge commit introduces. Merge conflict resolutions or manual
amendments to merge commits are not preserved.
This uses the --interactive machinery internally, but combining it
with the --interactive option explicitly is generally not a good
idea unless you know what you are doing (see BUGS below).
See also INCOMPATIBLE OPTIONS below.
 -x &lt;cmd&gt; 
 --exec &lt;cmd&gt; 
Append "exec &lt;cmd&gt;" after each line creating a commit in the
final history. &lt;cmd&gt; will be interpreted as one or more shell
commands.
You may execute several commands by either using one instance of --exec
with several commands:
git rebase -i --exec "cmd1 &amp;&amp; cmd2 &amp;&amp; ..."
or by giving more than one --exec:
git rebase -i --exec "cmd1" --exec "cmd2" --exec ...
If --autosquash is used, "exec" lines will not be appended for
the intermediate commits, and will only appear at the end of each
squash/fixup series.
This uses the --interactive machinery internally, but it can be run
without an explicit --interactive.
See also INCOMPATIBLE OPTIONS below.
 --root 
Rebase all commits reachable from &lt;branch&gt;, instead of
limiting them with an &lt;upstream&gt;.  This allows you to rebase
the root commit(s) on a branch.  When used with --onto, it
will skip changes already contained in &lt;newbase&gt; (instead of
&lt;upstream&gt;) whereas without --onto it will operate on every change.
When used together with both --onto and --preserve-merges,
all root commits will be rewritten to have &lt;newbase&gt; as parent
instead.
See also INCOMPATIBLE OPTIONS below.
 --autosquash 
 --no-autosquash 
When the commit log message begins with "squash! …​" (or
"fixup! …​"), and there is already a commit in the todo list that
matches the same ..., automatically modify the todo list of rebase
-i so that the commit marked for squashing comes right after the
commit to be modified, and change the action of the moved commit
from pick to squash (or fixup).  A commit matches the ... if
the commit subject matches, or if the ... refers to the commit’s
hash. As a fall-back, partial matches of the commit subject work,
too.  The recommended way to create fixup/squash commits is by using
the --fixup/--squash options of git-commit[1].
If the --autosquash option is enabled by default using the
configuration variable rebase.autoSquash, this option can be
used to override and disable this setting.
See also INCOMPATIBLE OPTIONS below.
 --autostash 
 --no-autostash 
Automatically create a temporary stash entry before the operation
begins, and apply it after the operation ends.  This means
that you can run rebase on a dirty worktree.  However, use
with care: the final stash application after a successful
rebase might result in non-trivial conflicts.
INCOMPATIBLE OPTIONS
git-rebase has many flags that are incompatible with each other,
predominantly due to the fact that it has three different underlying
implementations:
one based on git-am[1] (the default)
one based on git-merge-recursive (merge backend)
one based on git-cherry-pick[1] (interactive backend)
Flags only understood by the am backend:
--committer-date-is-author-date
--ignore-date
--whitespace
--ignore-whitespace
-C
Flags understood by both merge and interactive backends:
--merge
--strategy
--strategy-option
--allow-empty-message
Flags only understood by the interactive backend:
--[no-]autosquash
--rebase-merges
--preserve-merges
--interactive
--exec
--keep-empty
--autosquash
--edit-todo
--root when used in combination with --onto
Other incompatible flag pairs:
--preserve-merges and --interactive
--preserve-merges and --signoff
--preserve-merges and --rebase-merges
--rebase-merges and --strategy
--rebase-merges and --strategy-option
BEHAVIORAL DIFFERENCES
empty commits:
am-based rebase will drop any "empty" commits, whether the
commit started empty (had no changes relative to its parent to
start with) or ended empty (all changes were already applied
upstream in other commits).
merge-based rebase does the same.
interactive-based rebase will by default drop commits that
started empty and halt if it hits a commit that ended up empty.
The `--keep-empty` option exists for interactive rebases to allow
it to keep commits that started empty.
directory rename detection:
merge-based and interactive-based rebases work fine with
directory rename detection.  am-based rebases sometimes do not.
MERGE STRATEGIES
The merge mechanism (git merge and git pull commands) allows the
backend merge strategies to be chosen with -s option.  Some strategies
can also take their own options, which can be passed by giving -X&lt;option&gt;
arguments to git merge and/or git pull.
 resolve 
This can only resolve two heads (i.e. the current branch
and another branch you pulled from) using a 3-way merge
algorithm.  It tries to carefully detect criss-cross
merge ambiguities and is considered generally safe and
fast.
 recursive 
This can only resolve two heads using a 3-way merge
algorithm.  When there is more than one common
ancestor that can be used for 3-way merge, it creates a
merged tree of the common ancestors and uses that as
the reference tree for the 3-way merge.  This has been
reported to result in fewer merge conflicts without
causing mismerges by tests done on actual merge commits
taken from Linux 2.6 kernel development history.
Additionally this can detect and handle merges involving
renames, but currently cannot make use of detected
copies.  This is the default merge strategy when pulling
or merging one branch.
The recursive strategy can take the following options:
 ours 
This option forces conflicting hunks to be auto-resolved cleanly by
favoring our version.  Changes from the other tree that do not
conflict with our side are reflected to the merge result.
For a binary file, the entire contents are taken from our side.
This should not be confused with the ours merge strategy, which does not
even look at what the other tree contains at all.  It discards everything
the other tree did, declaring our history contains all that happened in it.
 theirs 
This is the opposite of ours; note that, unlike ours, there is
no theirs merge strategy to confuse this merge option with.
 patience 
With this option, merge-recursive spends a little extra time
to avoid mismerges that sometimes occur due to unimportant
matching lines (e.g., braces from distinct functions).  Use
this when the branches to be merged have diverged wildly.
See also git-diff[1] --patience.
 diff-algorithm=[patience|minimal|histogram|myers] 
Tells merge-recursive to use a different diff algorithm, which
can help avoid mismerges that occur due to unimportant matching
lines (such as braces from distinct functions).  See also
git-diff[1] --diff-algorithm.
 ignore-space-change 
 ignore-all-space 
 ignore-space-at-eol 
 ignore-cr-at-eol 
Treats lines with the indicated type of whitespace change as
unchanged for the sake of a three-way merge.  Whitespace
changes mixed with other changes to a line are not ignored.
See also git-diff[1] -b, -w,
--ignore-space-at-eol, and --ignore-cr-at-eol.
If their version only introduces whitespace changes to a line,
our version is used;
If our version introduces whitespace changes but their
version includes a substantial change, their version is used;
Otherwise, the merge proceeds in the usual way.
 renormalize 
This runs a virtual check-out and check-in of all three stages
of a file when resolving a three-way merge.  This option is
meant to be used when merging branches with different clean
filters or end-of-line normalization rules.  See "Merging
branches with differing checkin/checkout attributes" in
gitattributes[5] for details.
 no-renormalize 
Disables the renormalize option.  This overrides the
merge.renormalize configuration variable.
 no-renames 
Turn off rename detection. This overrides the merge.renames
configuration variable.
See also git-diff[1] --no-renames.
 find-renames[=&lt;n&gt;] 
Turn on rename detection, optionally setting the similarity
threshold.  This is the default. This overrides the
merge.renames configuration variable.
See also git-diff[1] --find-renames.
 rename-threshold=&lt;n&gt; 
Deprecated synonym for find-renames=&lt;n&gt;.
 subtree[=&lt;path&gt;] 
This option is a more advanced form of subtree strategy, where
the strategy makes a guess on how two trees must be shifted to
match with each other when merging.  Instead, the specified path
is prefixed (or stripped from the beginning) to make the shape of
two trees to match.
 octopus 
This resolves cases with more than two heads, but refuses to do
a complex merge that needs manual resolution.  It is
primarily meant to be used for bundling topic branch
heads together.  This is the default merge strategy when
pulling or merging more than one branch.
 ours 
This resolves any number of heads, but the resulting tree of the
merge is always that of the current branch head, effectively
ignoring all changes from all other branches.  It is meant to
be used to supersede old development history of side
branches.  Note that this is different from the -Xours option to
the recursive merge strategy.
 subtree 
This is a modified recursive strategy. When merging trees A and
B, if B corresponds to a subtree of A, B is first adjusted to
match the tree structure of A, instead of reading the trees at
the same level. This adjustment is also done to the common
ancestor tree.
With the strategies that use 3-way merge (including the default, recursive),
if a change is made on both branches, but later reverted on one of the
branches, that change will be present in the merged result; some people find
this behavior confusing.  It occurs because only the heads and the merge base
are considered when performing a merge, not the individual commits.  The merge
algorithm therefore considers the reverted change as no change at all, and
substitutes the changed version instead.
NOTES
You should understand the implications of using git rebase on a
repository that you share.  See also RECOVERING FROM UPSTREAM REBASE
below.
When the git-rebase command is run, it will first execute a "pre-rebase"
hook if one exists.  You can use this hook to do sanity checks and
reject the rebase if it isn’t appropriate.  Please see the template
pre-rebase hook script for an example.
Upon completion, &lt;branch&gt; will be the current branch.
INTERACTIVE MODE
Rebasing interactively means that you have a chance to edit the commits
which are rebased.  You can reorder the commits, and you can
remove them (weeding out bad or otherwise unwanted patches).
The interactive mode is meant for this type of workflow:
have a wonderful idea
hack on the code
prepare a series for submission
submit
where point 2. consists of several instances of
a) regular use
finish something worthy of a commit
commit
b) independent fixup
realize that something does not work
fix that
commit it
Sometimes the thing fixed in b.2. cannot be amended to the not-quite
perfect commit it fixes, because that commit is buried deeply in a
patch series.  That is exactly what interactive rebase is for: use it
after plenty of "a"s and "b"s, by rearranging and editing
commits, and squashing multiple commits into one.
Start it with the last commit you want to retain as-is:
git rebase -i &lt;after-this-commit&gt;
An editor will be fired up with all the commits in your current branch
(ignoring merge commits), which come after the given commit.  You can
reorder the commits in this list to your heart’s content, and you can
remove them.  The list looks more or less like this:
pick deadbee The oneline of this commit
pick fa1afe1 The oneline of the next commit
...
The oneline descriptions are purely for your pleasure; git rebase will
not look at them but at the commit names ("deadbee" and "fa1afe1" in this
example), so do not delete or edit the names.
By replacing the command "pick" with the command "edit", you can tell
git rebase to stop after applying that commit, so that you can edit
the files and/or the commit message, amend the commit, and continue
rebasing.
If you just want to edit the commit message for a commit, replace the
command "pick" with the command "reword".
To drop a commit, replace the command "pick" with "drop", or just
delete the matching line.
If you want to fold two or more commits into one, replace the command
"pick" for the second and subsequent commits with "squash" or "fixup".
If the commits had different authors, the folded commit will be
attributed to the author of the first commit.  The suggested commit
message for the folded commit is the concatenation of the commit
messages of the first commit and of those with the "squash" command,
but omits the commit messages of commits with the "fixup" command.
git rebase will stop when "pick" has been replaced with "edit" or
when a command fails due to merge errors. When you are done editing
and/or resolving conflicts you can continue with git rebase --continue.
For example, if you want to reorder the last 5 commits, such that what
was HEAD~4 becomes the new HEAD. To achieve that, you would call
git rebase like this:
$ git rebase -i HEAD~5
And move the first patch to the end of the list.
You might want to preserve merges, if you have a history like this:
           X
            \
         A---M---B
        /
---o---O---P---Q
Suppose you want to rebase the side branch starting at "A" to "Q". Make
sure that the current HEAD is "B", and call
$ git rebase -i -p --onto Q O
Reordering and editing commits usually creates untested intermediate
steps.  You may want to check that your history editing did not break
anything by running a test, or at least recompiling at intermediate
points in history by using the "exec" command (shortcut "x").  You may
do so by creating a todo list like this one:
pick deadbee Implement feature XXX
fixup f1a5c00 Fix to feature XXX
exec make
pick c0ffeee The oneline of the next commit
edit deadbab The oneline of the commit after
exec cd subdir; make test
...
The interactive rebase will stop when a command fails (i.e. exits with
non-0 status) to give you an opportunity to fix the problem. You can
continue with git rebase --continue.
The "exec" command launches the command in a shell (the one specified
in $SHELL, or the default shell if $SHELL is not set), so you can
use shell features (like "cd", "&gt;", ";" …​). The command is run from
the root of the working tree.
$ git rebase -i --exec "make test"
This command lets you check that intermediate commits are compilable.
The todo list becomes like that:
pick 5928aea one
exec make test
pick 04d0fda two
exec make test
pick ba46169 three
exec make test
pick f4593f9 four
exec make test
SPLITTING COMMITS
In interactive mode, you can mark commits with the action "edit".  However,
this does not necessarily mean that git rebase expects the result of this
edit to be exactly one commit.  Indeed, you can undo the commit, or you can
add other commits.  This can be used to split a commit into two:
Start an interactive rebase with git rebase -i &lt;commit&gt;^, where
&lt;commit&gt; is the commit you want to split.  In fact, any commit range
will do, as long as it contains that commit.
Mark the commit you want to split with the action "edit".
When it comes to editing that commit, execute git reset HEAD^.  The
effect is that the HEAD is rewound by one, and the index follows suit.
However, the working tree stays the same.
Now add the changes to the index that you want to have in the first
commit.  You can use git add (possibly interactively) or
git gui (or both) to do that.
Commit the now-current index with whatever commit message is appropriate
now.
Repeat the last two steps until your working tree is clean.
Continue the rebase with git rebase --continue.
If you are not absolutely sure that the intermediate revisions are
consistent (they compile, pass the testsuite, etc.) you should use
git stash to stash away the not-yet-committed changes
after each commit, test, and amend the commit if fixes are necessary.
RECOVERING FROM UPSTREAM REBASE
Rebasing (or any other form of rewriting) a branch that others have
based work on is a bad idea: anyone downstream of it is forced to
manually fix their history.  This section explains how to do the fix
from the downstream’s point of view.  The real fix, however, would be
to avoid rebasing the upstream in the first place.
To illustrate, suppose you are in a situation where someone develops a
subsystem branch, and you are working on a topic that is dependent
on this subsystem.  You might end up with a history like the
following:
    o---o---o---o---o---o---o---o  master
	 \
	  o---o---o---o---o  subsystem
			   \
			    *---*---*  topic
If subsystem is rebased against master, the following happens:
    o---o---o---o---o---o---o---o  master
	 \			 \
	  o---o---o---o---o	  o'--o'--o'--o'--o'  subsystem
			   \
			    *---*---*  topic
If you now continue development as usual, and eventually merge topic
to subsystem, the commits from subsystem will remain duplicated forever:
    o---o---o---o---o---o---o---o  master
	 \			 \
	  o---o---o---o---o	  o'--o'--o'--o'--o'--M	 subsystem
			   \			     /
			    *---*---*-..........-*--*  topic
Such duplicates are generally frowned upon because they clutter up
history, making it harder to follow.  To clean things up, you need to
transplant the commits on topic to the new subsystem tip, i.e.,
rebase topic.  This becomes a ripple effect: anyone downstream from
topic is forced to rebase too, and so on!
There are two kinds of fixes, discussed in the following subsections:
 Easy case: The changes are literally the same. 
This happens if the subsystem rebase was a simple rebase and
had no conflicts.
 Hard case: The changes are not the same. 
This happens if the subsystem rebase had conflicts, or used
--interactive to omit, edit, squash, or fixup commits; or
if the upstream used one of commit --amend, reset, or
filter-branch.
The easy case
Only works if the changes (patch IDs based on the diff contents) on
subsystem are literally the same before and after the rebase
subsystem did.
In that case, the fix is easy because git rebase knows to skip
changes that are already present in the new upstream.  So if you say
(assuming you’re on topic)
    $ git rebase subsystem
you will end up with the fixed history
    o---o---o---o---o---o---o---o  master
				 \
				  o'--o'--o'--o'--o'  subsystem
						   \
						    *---*---*  topic
The hard case
Things get more complicated if the subsystem changes do not exactly
correspond to the ones before the rebase.
Note
While an "easy case recovery" sometimes appears to be successful
      even in the hard case, it may have unintended consequences.  For
      example, a commit that was removed via git rebase
      --interactive will be resurrected!
The idea is to manually tell git rebase "where the old subsystem
ended and your topic began", that is, what the old merge-base
between them was.  You will have to find a way to name the last commit
of the old subsystem, for example:
With the subsystem reflog: after git fetch, the old tip of
subsystem is at subsystem@{1}.  Subsequent fetches will
increase the number.  (See git-reflog[1].)
Relative to the tip of topic: knowing that your topic has three
commits, the old tip of subsystem must be topic~3.
You can then transplant the old subsystem..topic to the new tip by
saying (for the reflog case, and assuming you are on topic already):
    $ git rebase --onto subsystem subsystem@{1}
The ripple effect of a "hard case" recovery is especially bad:
everyone downstream from topic will now have to perform a "hard
case" recovery too!
REBASING MERGES
The interactive rebase command was originally designed to handle
individual patch series. As such, it makes sense to exclude merge
commits from the todo list, as the developer may have merged the
then-current master while working on the branch, only to rebase
all the commits onto master eventually (skipping the merge
commits).
However, there are legitimate reasons why a developer may want to
recreate merge commits: to keep the branch structure (or "commit
topology") when working on multiple, inter-related branches.
In the following example, the developer works on a topic branch that
refactors the way buttons are defined, and on another topic branch
that uses that refactoring to implement a "Report a bug" button. The
output of git log --graph --format=%s -5 may look like this:
*   Merge branch 'report-a-bug'
|\
| * Add the feedback button
* | Merge branch 'refactor-button'
|\ \
| |/
| * Use the Button class for all buttons
| * Extract a generic Button class from the DownloadButton one
The developer might want to rebase those commits to a newer master
while keeping the branch topology, for example when the first topic
branch is expected to be integrated into master much earlier than the
second one, say, to resolve merge conflicts with changes to the
DownloadButton class that made it into master.
This rebase can be performed using the --rebase-merges option.
It will generate a todo list looking like this:
label onto
# Branch: refactor-button
reset onto
pick 123456 Extract a generic Button class from the DownloadButton one
pick 654321 Use the Button class for all buttons
label refactor-button
# Branch: report-a-bug
reset refactor-button # Use the Button class for all buttons
pick abcdef Add the feedback button
label report-a-bug
reset onto
merge -C a1b2c3 refactor-button # Merge 'refactor-button'
merge -C 6f5e4d report-a-bug # Merge 'report-a-bug'
In contrast to a regular interactive rebase, there are label, reset
and merge commands in addition to pick ones.
The label command associates a label with the current HEAD when that
command is executed. These labels are created as worktree-local refs
(refs/rewritten/&lt;label&gt;) that will be deleted when the rebase
finishes. That way, rebase operations in multiple worktrees linked to
the same repository do not interfere with one another. If the label
command fails, it is rescheduled immediately, with a helpful message how
to proceed.
The reset command resets the HEAD, index and worktree to the specified
revision. It is isimilar to an exec git reset --hard &lt;label&gt;, but
refuses to overwrite untracked files. If the reset command fails, it is
rescheduled immediately, with a helpful message how to edit the todo list
(this typically happens when a reset command was inserted into the todo
list manually and contains a typo).
The merge command will merge the specified revision(s) into whatever
is HEAD at that time. With -C &lt;original-commit&gt;, the commit message of
the specified merge commit will be used. When the -C is changed to
a lower-case -c, the message will be opened in an editor after a
successful merge so that the user can edit the message.
If a merge command fails for any reason other than merge conflicts (i.e.
when the merge operation did not even start), it is rescheduled immediately.
At this time, the merge command will always use the recursive
merge strategy for regular merges, and octopus for octopus merges,
strategy, with no way to choose a different one. To work around
this, an exec command can be used to call git merge explicitly,
using the fact that the labels are worktree-local refs (the ref
refs/rewritten/onto would correspond to the label onto, for example).
Note: the first command (label onto) labels the revision onto which
the commits are rebased; The name onto is just a convention, as a nod
to the --onto option.
It is also possible to introduce completely new merge commits from scratch
by adding a command of the form merge &lt;merge-head&gt;. This form will
generate a tentative commit message and always open an editor to let the
user edit it. This can be useful e.g. when a topic branch turns out to
address more than a single concern and wants to be split into two or
even more topic branches. Consider this todo list:
pick 192837 Switch from GNU Makefiles to CMake
pick 5a6c7e Document the switch to CMake
pick 918273 Fix detection of OpenSSL in CMake
pick afbecd http: add support for TLS v1.3
pick fdbaec Fix detection of cURL in CMake on Windows
The one commit in this list that is not related to CMake may very well
have been motivated by working on fixing all those bugs introduced by
switching to CMake, but it addresses a different concern. To split this
branch into two topic branches, the todo list could be edited like this:
label onto
pick afbecd http: add support for TLS v1.3
label tlsv1.3
reset onto
pick 192837 Switch from GNU Makefiles to CMake
pick 918273 Fix detection of OpenSSL in CMake
pick fdbaec Fix detection of cURL in CMake on Windows
pick 5a6c7e Document the switch to CMake
label cmake
reset onto
merge tlsv1.3
merge cmake
BUGS
The todo list presented by --preserve-merges --interactive does not
represent the topology of the revision graph.  Editing commits and
rewording their commit messages should work fine, but attempts to
reorder commits tend to produce counterintuitive results. Use
--rebase-merges in such scenarios instead.
For example, an attempt to rearrange
1 --- 2 --- 3 --- 4 --- 5
to
1 --- 2 --- 4 --- 3 --- 5
by moving the "pick 4" line will result in the following history:
	3
       /
1 --- 2 --- 4 --- 5
GIT
Part of the git[1] suite
    About this site
    Patches, suggestions, and comments are welcome.
    Git is a member of Software Freedom Conservancy
