        About
            Branching and Merging
            Small and Fast
            Distributed
            Data Assurance
            Staging Area
            Free and Open Source
            Trademark
        Documentation
            Reference
            Book
            Videos
            External Links
        Downloads
            GUI Clients
            Logos
        Community
  Português (Brasil) ▾
  Localized versions of git-diff manual
        Deutsch
        English
        Français
        Português (Brasil)
    Want to read in your language or fix typos? You can help translate this page.
    Topics ▾
      Setup and Config
  git
  config
  help
  bugreport
      Getting and Creating Projects
  init
  clone
      Basic Snapshotting
  add
  status
  diff
  commit
  notes
  restore
  reset
  rm
  mv
      Branching and Merging
  branch
  checkout
  switch
  merge
  mergetool
  log
  stash
  tag
  worktree
      Sharing and Updating Projects
  fetch
  pull
  push
  remote
  submodule
      Inspection and Comparison
  show
  log
  diff
  difftool
  range-diff
  shortlog
  describe
      Patching
  apply
  cherry-pick
  diff
  rebase
  revert
      Debugging
  bisect
  blame
  grep
      Email
  am
  apply
  format-patch
  send-email
  request-pull
      External Systems
  svn
  fast-import
      Server Admin
  daemon
  update-server-info
      Guides
  gitattributes
  Command-line interface conventions
  Everyday Git
  Frequently Asked Questions (FAQ)
  Glossary
  githooks
  gitignore
  gitmodules
  Revisions
  Submodules
  Tutorial
  Workflows
      Administration
  clean
  gc
  fsck
  reflog
  filter-branch
  instaweb
  archive
  bundle
      Plumbing Commands
  cat-file
  check-ignore
  checkout-index
  commit-tree
  count-objects
  diff-index
  for-each-ref
  hash-object
  ls-files
  ls-tree
  merge-base
  read-tree
  rev-list
  rev-parse
  show-ref
  symbolic-ref
  update-index
  update-ref
  verify-pack
  write-tree
      Latest version
       ▾ 
git-diff last updated in 2.28.0
  Changes in the git-diff manual
        2.28.0
          07/27/20
        2.25.2 → 2.27.0 no changes
        2.25.1
          02/17/20
        2.25.0
          01/13/20
        2.24.1 → 2.24.3 no changes
        2.24.0
          11/04/19
        2.22.1 → 2.23.3 no changes
        2.22.0
          06/07/19
        2.21.1 → 2.21.3 no changes
        2.21.0
          02/24/19
        2.20.1 → 2.20.4 no changes
        2.20.0
          12/09/18
        2.19.3 → 2.19.5 no changes
        2.19.2
          11/21/18
        2.19.1 no changes
        2.19.0
          09/10/18
        2.18.1 → 2.18.4 no changes
        2.18.0
          06/21/18
        2.17.1 → 2.17.5 no changes
        2.17.0
          04/02/18
        2.16.6
          12/06/19
        2.15.4
          12/06/19
        2.14.6
          12/06/19
        2.13.7
          05/22/18
        2.12.5
          09/22/17
        2.11.4
          09/22/17
        2.10.5 no changes
        2.9.5
          07/30/17
        2.8.6
          07/30/17
        2.7.6 no changes
        2.6.7
          05/05/17
        2.5.6
          05/05/17
        2.4.12
          05/05/17
        2.3.10
          09/28/15
    See more previous releases → -->
    Check your version of git by running
    $
NOME
git-diff - Exibe as mudanças entre os commits, o commit, a árvore de
trabalho, etc
RESUMO
git diff [&lt;options&gt;] [&lt;commit&gt;] [--] [&lt;caminho&gt;…​]
git diff [&lt;options&gt;] --cached [&lt;commit&gt;] [--] [&lt;caminho&gt;…​]
git diff [&lt;options&gt;] &lt;commit&gt; [&lt;commit&gt;…​] &lt;commit&gt; [--] [&lt;caminho&gt;…​]
git diff [&lt;options&gt;] &lt;commit&gt;…​&lt;commit&gt; [--] [&lt;caminho&gt;…​]
git diff [&lt;options&gt;] &lt;blob&gt; &lt;blob&gt;
git diff [&lt;options&gt;] --no-index [--] &lt;caminho&gt; &lt;caminho&gt;
DESCRIÇÃO
Exibe as alterações entre a árvore de trabalho, o índice ou uma árvore, as
alterações entre o índice e uma árvore, as alterações entre as duas árvores,
nas alterações resultantes de uma mesclagem, nas alterações entre dois
objetos gota ou nas alterações entre dois arquivos no disco.
 git diff [&lt;opções&gt;] [--] [&lt;caminho&gt;…​] 
Este formulário serve para exibir as alterações feitas em relação ao índice
(área de preparação para o próximo commit).  Em outras palavras, as
diferenças são as que você pode informar ao Git para adicionar ao índice,
mas ainda não o fez.   Você pode preparar essas alterações utilizando
git-add[1].
 git diff [&lt;opções&gt;] --no-index [--] &lt;caminho&gt; &lt;caminho&gt; 
Este formulário serve para comparar os dois caminhos utilizados no sistema
de arquivos.  Você pode omitir a opção --no-index durante a execução do
comando em uma árvore de trabalho controlado pelo Git e pelo menos um dos
pontos dos caminhos fora da árvore de trabalho ou ao executar o comando fora
de uma árvore de trabalho que é controlado pelo Git. Este formulário implica
no uso da opção --exit-code.
 git diff [&lt;opções&gt;] --cached [&lt;commit&gt;] [--] [&lt;caminho&gt;…​] 
Este formulário serve para exibir as alterações feitas em relação ao próximo
commit relativo ao &lt;commit&gt; informado.  Geralmente você vai querer uma
comparação com o commit mais recente, portanto, se não fizer o &lt;commit&gt; a
predefinição retorna para HEAD.  Caso HEAD não exista (como por exemplo,
os galhos que ainda vão aparecer) e um &lt;commit&gt; não tenha sido feito,
exibe todas as alterações em etapas.  --staged é um sinônimo da opção
--cached.
 git diff [&lt;opções&gt;] &lt;commit&gt; [--] [&lt;caminho&gt;…​] 
Este formulário exibe as modificações feitas por você na sua árvore de
trabalho relativo ao nome do &lt;commit&gt;.  É possível utilizar o HEAD para
compará-lo com o commit mais recente ou para comparar com o cume de um ramo
diferente.
 git diff [&lt;opções&gt;] &lt;commit&gt; &lt;commit&gt; [--] [&lt;caminho&gt;…​] 
Isso é para exibir as alterações entre os dois &lt;commits&gt; arbitrários.
 git diff [&lt;opções&gt;] &lt;commit&gt;..&lt;commit&gt; [--] [&lt;caminho&gt;…​] 
Isso é um sinônimo do formulário anterior.  Caso o &lt;commitir&gt; de um lado
seja omitido, ele terá o mesmo efeito que usar HEAD.
 git diff [&lt;opções&gt;] &lt;commit&gt; [&lt;commit&gt;…​] &lt;commit&gt; [--] [&lt;caminho&gt;…​] 
Este formulário serve para visualizar os resultados da mesclagem de um
commit.  Os primeiros &lt;commit&gt; que forem listados devem ser a mesclagem em
si; os dois ou mais commits restantes devem ser seus pais.  Uma maneira
conveniente de produzir o conjunto desejado das revisões é usar o sufixo
^@.  Como por exemplo, caso o  master nomeie a mesclagem de um
commit, o comando git diff master^@ retorna o mesmo diff combinado como no
comando git show master.
 git diff [&lt;opções&gt;] &lt;commit&gt;...&lt;commit&gt; [--] [&lt;caminho&gt;…​] 
Este formulário é para exibir as alterações no ramo que contenha até o
segundo &lt;commit&gt;, iniciando com um ancestral comum de ambos os
&lt;commit&gt;.  git diff A\...B é o equivalente a um git diff $(git
merge-base A B) B.  Você pode omitir qualquer um dos &lt;commit&gt; que tem o
mesmo efeito que usar HEAD.
No caso de você estar fazendo algo exótico, deve-se notar que todos os
&lt;commit&gt; na descrição acima, exceto nas duas últimas formas que usam as
notações "..", podem ser qualquer &lt;árvore&gt;.
Para obter uma lista mais completa de maneiras de soletrar um &lt;commit&gt;,
consulte a seção "DEFININDO AS REVISÕES" em gitrevisions[7].  No
entanto, diff é sobre comparar dois endpoints, e não os intervalos, as
notações de intervalo ("&lt;commit&gt;.. &lt;commit&gt;" e "&lt;commit&gt;... &lt;commit&gt;") não
significam um intervalo definido na seção "DEFININDO AS REVISÕES" em
gitrevisions[7].
 git diff [&lt;opções&gt;] &lt;blob&gt; &lt;blob&gt; 
Este formulário serve para exibir as alterações feitas entre o conteúdo
bruto de dois objetos gota.
OPÇÕES
 -p 
 -u 
 --patch 
Gere um patch (consulte a seção sobre a geração de patches).
Esta é a predefinição.
 -s 
 --no-patch 
Suprime a saída diff. Útil para comandos como git show que por
predefinição exibem a correção ou para cancelar o efeito de --patch.
 -U&lt;n&gt; 
 --unified=&lt;n&gt; 
Gere diffs com uma quantidade de &lt;n&gt; linhas de contexto em vez das três
usuais. Implica no uso da opção --patch.
Implica no uso da opção -p.
 --output=&lt;arquivo&gt; 
Escreve o arquivo para um determinado arquivo em vez de stdout.
 --output-indicator-new=&lt;caractere&gt; 
 --output-indicator-old=&lt;caractere&gt; 
 --output-indicator-context=&lt;caractere&gt; 
Informe o caractere que será utilizado para indicar as linhas novas, antigas
ou do contexto no patch que foi gerado. Normalmente eles são +, - e ' '
respectivamente.
 --raw 
Gere o diff no formato bruto (raw).
 --patch-with-raw 
É um sinônimo para -p --raw.
 --indent-heuristic 
Ativa a heurística que altera os limites dos pedaços diferentes para
facilitar a leitura dos patches. Esta é a predefinição.
 --no-indent-heuristic 
Desative a heurística de recuo.
 --minimal 
Expenda um tempo extra para garantir que o menor diferencial possível seja
produzido.
 --patience 
Gere um diff utilizando o algoritmo "patience diff" (ou diff de paciência).
 --histogram 
Gere um diff utilizando o algoritmo "histogram diff" (ou diff de
histograma).
 --anchored=&lt;texto&gt; 
Gere um diff utilizando o algoritmo "anchored diff" (ou diff ancorado).
Esta opção pode ser especificada mais de uma vez.
Caso uma linha exista na origem e no destino, exista apenas uma vez e comece
com este texto, este algoritmo tenta impedir que apareça como uma exclusão
ou adição na saída. O algoritmo "patience diff" é utilizado internamente.
 --diff-algorithm={patience|minimal|histogram|myers} 
Escolha um algoritmo diff. As variantes são as seguintes:
 default, myers 
O algoritmo diff ganancioso básico. Atualmente, este é o valor predefinido.
 minimal 
Expenda um tempo extra para garantir que o menor diferencial possível seja
produzido.
 patience 
Utilize o algoritmo "patience diff" (ou diff de paciência) ao gerar os
patches.
 histogram 
Este algoritmo estende o algoritmo "patience" (paciência) para "se
compatível com os elementos comuns com baixa ocorrência".
Caso tenha configurado uma variável diff.algorithm para um valor sem
predefinição e quer utilizar a variável predefinida por exemplo, então
utilize a opção --diff-algorithm=default.
 --stat[=&lt;largura&gt;[,&lt;largura-do-nome&gt;[,&lt;count&gt;]]] 
Gera um diffstat. É predefinido que o espaço necessário será utilizado para
a parte do nome do arquivo e o restante para a parte do grafo. A largura
máxima a predefinição retorna para a largura do terminal ou 80 colunas, caso
não esteja conectada em um terminal e pode ser substituída por
&lt;largura&gt;. A largura da parte do nome do arquivo pode ser limitada,
fornecendo outra largura &lt;largura-do-nome&gt; após uma vírgula. A largura da
parte do grafo pode ser limitada utilizando --stat-graph-width=&lt;largura&gt;
(afeta todos os comandos que geram um grafo estatístico) ou definindo
diff.statGraphWidth=&lt;largura&gt; (não afeta o git format-patch).  Ao
fornecer um terceiro parâmetro &lt;count&gt;, é possível limitar a saída às
primeiras linhas &lt;count&gt;, seguidas por ... caso haja mais.
Estes parâmetros também podem ser ajustados individualmente com
--stat-width=&lt;largura&gt;, --stat-name-width=&lt;largura-do-nome&gt; e
--stat-count=&lt;count&gt;.
 --compact-summary 
A saída de um resumo condensado das informações do cabeçalho estendido como
criações ou exclusões dos arquivos ("novo" ou "desaparecido", opcionalmente
"+l" se for um link simbólico) e alterações do modo ("+x" ou "-x" para
adicionar ou remover um bit executável, respectivamente) no diffstat. As
informações são colocadas entre a parte do nome do arquivo e a parte do
grafo. Implica no uso da opção --stat.
 --numstat 
Semelhante ao --stat, exibe a quantidade de linhas adicionadas, excluídas,
em notação decimal e o nome do caminho sem abreviação, para torná-lo mais
amigável à máquina.  Para arquivos binários, gera dois - em vez de 0 0.
 --shortstat 
Produz apenas a última linha do formato --stat contendo a quantidade total
dos arquivos modificados, assim como a quantidade de linhas adicionadas e
excluídas.
 -X[&lt;parâmetro1,parâmetro2,…​&gt;] 
 --dirstat[=&lt;parâmetro1,parâmetro2,…​&gt;] 
Produz a distribuição da quantidade relativa de alterações para cada
subdiretório. O comportamento do --dirstat pode ser customizado passando
uma lista de parâmetros separados por vírgula.  As predefinições são
controlados pela variável de configuração diff.dirstat (veja
git-config[1]).  Os seguintes parâmetros estão disponíveis:
 changes 
Calcule os números "dirstat" contando as linhas que foram removidas da fonte
ou adicionadas ao destino. Ignora a quantidade de movimentos de código puro
em um arquivo.  Em outras palavras, reorganizar as linhas em um arquivo não
conta tanto quanto as outras alterações.  Este é o comportamento predefinido
quando nenhum parâmetro for utilizado.
 lines 
Calcule os números "dirstat" fazendo a análise diferencial com base nas
linhas regulares e somando as contagens das linhas removidas /
adicionadas. (Para os arquivos binários, conte em blocos de 64 bytes, pois
os arquivos binários não têm um conceito natural de linhas). Este é um
comportamento mais dispendioso do --dirstat do que o comportamento
changes (alterações), conta as linhas reorganizadas em um arquivo tanto
quanto as outras alterações. A produção resultante é consistente com o que
você obtém das outras opções --*stat.
 files 
Calcule os números "dirstat" contando a quantidade de arquivos alterados.
Cada arquivo alterado conta igualmente na análise do "dirstat". Este é o
comportamento computacional mais barato do --dirstat, pois não precisa
olhar o conteúdo do arquivo.
 cumulative 
Conta as alterações em um diretório herdeiro e também para o diretório de
origem.  Observe que, ao utilizar cumulative (cumulativo), a soma das
porcentagens relatadas pode exceder os 100%. O comportamento predefinido
(não cumulativo) pode ser especificado com o parâmetro noncumulative (não
cumulativo).
 &lt;limite&gt; 
Um parâmetro inteiro especifica uma porcentagem de corte (a predefinição
retorna para 3%).  Os diretórios que contribuem com menos que esta
porcentagem nas alterações não são exibidos na saída.
Exemplo: O seguinte contará os arquivos alterados, ignorando os diretórios
com menos de 10% da quantidade total dos arquivos alterados e acumulando as
contagens de um diretório-herdado nos diretórios-raiz:
---dirstat=arquivos,10,cumulative.
 --cumulative 
É um sinônimo para --dirstat=cumulative
 --dirstat-by-file[=&lt;parâmetro1,parâmetro2&gt;…​] 
É um sinônimo para --dirstat=arquivos,parâmetro1,parâmetro2...
 --summary 
Produza um resumo condensado das informações estendidas do cabeçalho, como
criações, renomeações e alterações do modo.
 --patch-with-stat 
É um sinônimo para -p --stat.
 -z 
Quando --raw, --numstat, --name-only ou --name-status tenha sido
utilizado, não una os nomes do caminho e utilize caracteres NUL como terminadores do campo de saída.
Sem esta opção, os nomes do caminho com caracteres "incomuns" são citados
como explicado na variável de configuração core.quotePath (veja
linkgit:git-config [1]).
 --name-only 
Exiba apenas os nomes dos arquivos que foram alterados.
 --name-status 
Exiba apenas os nomes e a condição atual dos arquivos que foram
alterados. Consulte a descrição da opção --diff-filter sobre o significado
das letras de condição.
 --submodule[=&lt;formato&gt;] 
Especifique como as diferenças nos submódulos são exibidos.  Ao especificar
--submodule=short, o formato short (curto) é utilizado.  Este formato
exibe apenas os nomes dos commits no início e no final do intervalo.  Ao
utilizar a opção --submodule ou --submodule=log, o formato log passa a
ser utilizado.  Este formato lista os commits no intervalo como o
git-submodule[1] summary (resumo) faz.  Ao utilizar a opção
--submodule=diff, o formato diff passa a ser utilizado.  Este formato
exibe uma comparação nas linhas das alterações no conteúdo do submódulo
entre o intervalo do commit.  A predefinição retorna para a opção de
configuração diff.submodule ou o formato short (curto) caso a opção da
configuração estiver desativada.
 --color[=&lt;quando&gt;] 
Exibe o diff colorido.  A opção --color (sem =&lt;quando&gt; por exemplo) é o
mesmo que a opção --color=always.  &lt;quando&gt; pode ser always (sempre),
never (nunca), ou auto.
Pode ser alterado pelas definições da configuração
color.ui e color.diff.
 --no-color 
Desativa o diff colorido.
Pode ser utilizado para substituir a definição da configuração.
É o mesmo que --color=never.
 --color-moved[=&lt;modo&gt;] 
As linhas de código que foram movidas são coloridas de maneira diferente.
Pode ser alterado através da pela definição da configuração diff.colorMoved.
O &lt;modo&gt; retorna para a predefinição como no caso a opção não seja utilizada
e para zebra caso a opção seja utilizada sem nenhum modo.
O modo deve ser um dos seguintes:
 no 
As linhas movidas não são destacadas.
 default 
É um sinônimo para zebra. Pode ser que isso mude para um modo mais
sensível no futuro.
 plain 
Qualquer linha adicionada em um local e removida em outro será colorida com
color.diff.newMoved.  Da mesma forma, color.diff.oldMoved será utilizado
para as linhas que forem removidas e que foram adicionadas em outro lugar no
diff. Este modo seleciona qualquer linha movida, mas não é muito útil em uma
revisão para determinar se um bloco do código foi movido sem permutação.
 blocks 
Os blocos de texto movidos com pelo menos 20 caracteres alfanuméricos são
detectados de forma ávida. Os blocos detectados são pintados utilizando a
cor color.diff.{old,new}Moved.  Os blocos adjacentes não podem ser
separados.
 zebra 
Os blocos de texto que foram movidos são detectados como no modo blocks
(blocos). Os blocos são pintados utilizando a cor
color.diff.{old,new}Moved ou color.diff.{old,new}MovedAlternative. A
alteração entre as duas cores indica que um novo bloco foi detectado.
 dimmed-zebra 
Semelhante ao zebra, porém é realizado o escurecimento adicional das
partes desinteressantes do código que foi movido. As linhas limítrofes dos
dois blocos adjacentes são considerados como interessantes, o resto como não
interessante.  dimmed_zebra é um sinônimo obsoleto.
 --no-color-moved 
Desativa a detecção de movimento. Pode ser utilizado para substituir a
definição da configuração. É o mesmo que --color-moved=no.
 --color-moved-ws=&lt;modos&gt; 
Configura como o espaço é ignorado durante a execução da detecção do mover
para --color-moved.
Pode ser definido através da definição da variável de configuração diff.colorMovedWS.
Estes modos podem ser utilizados como uma lista separada por vírgulas:
 no 
Não ignore os espaços quando realizar a detecção da ação de mover.
 ignore-space-at-eol 
Ignore as alterações no espaço na EOL (fim da linha).
 ignore-space-change 
Ignore as alterações na quantidade do espaço.  Ignora o espaço no final da
linha e considera todas as outras sequências de um ou mais caracteres de
espaço como equivalentes.
 ignore-all-space 
Ignore o espaço durante a comparação das linhas. Ignore as diferenças mesmo
que uma linha tenha espaços quando a outra linha não tiver nenhuma.
 allow-indentation-change 
Ignore inicialmente, qualquer espaço na detecção da ação de mover, em
seguida, agrupe os blocos do código que foram movidos apenas em um bloco
caso a alteração no espaço seja a mesma em cada linha. Isto é incompatível
com os outros modos.
 --no-color-moved-ws 
Não ignore os espaços quando realizar a detecção da ação de mover. Pode ser
utilizado para substituir a definição da configuração. É o mesmo que
--color-moved-ws=no.
 --word-diff[=&lt;modo&gt;] 
Exiba umadiff entre as palavras, usando o &lt;modo&gt; para delimitar as palavras
alteradas.  É predefinido que as palavras sejam delimitadas por espaços;
consulte --word-diff-regex abaixo.  O &lt;modo&gt; retorna para a predefinição
plain e deve ser um dos seguintes:
 color 
Destaque as palavras alteradas usando apenas as cores.  Implica no uso da
opção --color.
 plain 
Exiba as palavras como [-removed-] (removido) e {+added+} (adicionado).
Não faz nenhuma tentativa de escapar os delimitadores caso eles apareçam na
entrada, portanto, a saída pode ser ambígua.
 porcelain 
Use um formato especial orientado em linha destinado para a utilização com
um script.  As execuções adicionadas/removidas/inalteradas são impressas no
formato diff unificado tradicional, começando com um caractere +/-/` `
no início da linha e estendendo-se até o final.  As novas linhas na entrada
são representadas por um til ~ em uma linha própria.
 none 
Desative a palavra diff novamente.
Observe que, apesar do nome do primeiro modo, a cor é utilizada para realçar
as partes alteradas em todos os modos caso seja ativada.
 --word-diff-regex=&lt;expressão-regular&gt; 
Utilize uma &lt;expressão-regular&gt; para decidir o que uma palavra é em vez de
considerar as execuções dos espaços que não estejam vazios como uma
palavra.  Também implica no uso da opção --word-diff, a menos que já
esteja ativo.
Toda a coincidência não sobreposta do &lt;expressão-regular&gt; é considerado
como sendo uma palavra.  Qualquer coisa entre estas coincidências é
considerada um espaço e é ignorado(!) com o objetivo de encontrar as
diferenças.  Você pode anexar |[^[:space:]] à sua expressão regular para
garantir que ela coincida com todos os caracteres que não sejam espaços.
Uma coincidência que contenha uma nova linha é silenciosamente truncada(!)
na nova linha.
A opção --word-diff-regex=. por exemplo, tratará cada caractere como uma
palavra e coincidentemente, exibirá as diferenças caractere a caractere.
A expressão regular também pode ser definida através de um controlador do
diff ou uma opção de configuração, consulte gitattributes[5] or
git-config[1].  A concessão explícita substitui qualquer controle
diff ou uma configuração.  Os controles diff substituem as definições da
configuração.
 --color-words[=&lt;expressão-regular&gt;] 
Equivalente a --word-diff=color mais (caso um regex seja utilizado)
--word-diff-regex=&lt;expressão-regular&gt;.
 --no-renames 
Desative a detecção da ação de renomear, mesmo quando o arquivo de
configuração seja predefinido para tanto.
 --[no-]rename-empty 
Se usa ou não bolhas vazias como origem do nome.
 --check 
Avise caso as alterações introduzirem os marcadores de conflito ou os erros
de espaço.  A configuração core.whitespace define o que são considerados
erros de espaço.  É predefinido que os espaços à direita (incluindo as
linhas que consistem apenas de espaços) e um caractere de espaço que seja
imediatamente seguido por um caractere de tabulação dentro do recuo inicial
da linha, são considerados erros de espaço.  Encerra com uma condição
diferente de zero caso problemas sejam encontrados. Não é compatível com
--exit-code.
 --ws-error-highlight=&lt;tipo&gt; 
Destaque os erros de espaço nas linhas context (contexto), old (antigo)
ou new (novo) do diff.  Vários valores são separados por vírgula, none
redefine os valores anteriores, default redefine a lista para new e
all é uma abreviação para old,new,context.  Quando esta opção não é
utilizada e a variável de configuração diff.wsErrorHighlight não está
definida, apenas os erros de espaço nas linhas novas são destacados. Os
erros de espaço são coloridos com color.diff.whitespace.
 --full-index 
Em vez do primeiro punhado de caracteres, exiba os nomes completos dos
objetos bolha antes e depois da imagem na linha "index" ao produzir a saída
no formato patch.
 --binary 
Além de --full-index, gere um diff binário que possa ser aplicado com o
comando git-apply. Implica no uso da opção --patch.
 --abrev[=&lt;n&gt;] 
Em vez de exibir o nome completo do objeto hexadecimal com 40 bytes na
produção do formato diff-raw e nas linhas do cabeçalho da árvore diff, exiba
apenas um prefixo parcial.  Isso é independente da opção --full-index
acima, que controla o formato da produção da saída do diff-patch.  A
quantidade de dígitos fora do preestabelecido pode ser especificado com a
opção --abbrev=&lt;n&gt;.
 -B[&lt;n&gt;][/&lt;m&gt;] 
 --break-rewrites[=[&lt;n&gt;][/&lt;m&gt;]] 
Divida as alterações reescritas que foram completas em pares de exclusão e
criação. Isso serve a dois propósitos:
Afeta a maneira como uma mudança que equivale a uma reescrita total de um
arquivo, não como uma série de exclusão e inserção combinadas com poucas
linhas que coincidem textualmente com o contexto, e sim como uma única
exclusão de tudo o que é antigo seguido por um inserção única de tudo que
for novo, o número m controla este aspecto da opção -B (a predefinição
retorna para 60%). -B / 70% determina que menos de 30% do original deve
permanecer no resultado para que o Git considere-o como uma reescrita total
(ou seja, caso contrário, o patch resultante será uma série de exclusões e
inserções combinados com linhas de contexto).
Quando utilizado com a opção -M, um arquivo totalmente reescrito também é
considerado a fonte de uma renomeação (O -M geralmente considera apenas um
arquivo que desapareceu como a origem de uma renomeação), o número n
controla esse aspecto da opção -B (a predefinição retorna para 50%). O
-B20% determina que uma alteração com a adição e a exclusão em comparação
com 20% ou mais do tamanho do arquivo é elegível para ser selecionada como
uma possível fonte de renomeação para um outro arquivo.
 -M[&lt;n&gt;] 
 --find-renames[=&lt;n&gt;] 
Detecte as renomeações.
Caso n seja utilizado, é a limítrofe do índice da similaridade
(A quantidade de adições/exclusões comparado ao tamanho
do arquivo). -M90% significa que o Git deve considerar uma ação do par de
exclusão/adição para ser renomeado caso mais que 90% do arquivo
não tenha sido alterado.  Sem um sinal de %, a quantidade deve ser lida como
uma fração, com um ponto decimal antes dele.  -M5 se torna por exemplo
0.5, portanto, é o mesmo que -M50%.  Da mesma forma que -M05 é
o mesmo que -M5%.  Para limitar a detecção para renomeações exatas, utilize
-M100%.  A predefinição para o índice de similaridade é 50%.
 -C[&lt;n&gt;] 
 --find-copies[=&lt;n&gt;] 
Detecte as cópias e também o que for renomeado.  Consulte também
--find-copies-harder.  Caso n seja utilizado, ele terá o mesmo
significado que -M&lt;n&gt;.
 --find-copies-harder 
Por motivos de desempenho, a predefinição retorna para que a opção -C
encontre as cópias apenas caso o arquivo original da cópia tenha sido
modificado no mesmo conjunto de alterações.  Essa flag faz com que o comando
inspecione os arquivos que não modificados como candidatos à origem da
cópia.  Esta é uma operação muito dispendiosa em projetos grandes, portanto,
utilize-a com cuidado.  Tem o mesmo efeito caso a opção -C seja repetida.
 -D 
 --irreversible-delete 
Omita a imagem prévia que será excluída, ou seja, imprima apenas o
cabeçalho, mas não a diferença entre a pré-imagem e /dev/null. O patch
resultante não deve ser aplicado com com o comando patch ou git apply; é
apenas para pessoas que desejam se concentrar em revisar o texto após a
alteração. Além disso, a saída obviamente não possui informações suficientes
para aplicar esse patch em sentido inverso, mesmo manualmente, daí o nome da
opção.
Quando utilizado em conjunto com a opção -B, omita também a pré-imagem na
parte da exclusão de um par excluir/criar.
 -l&lt;num&gt; 
As opções -M e -C requerem um tempo de processamento O(n^2) em que n é a
quantidade de possíveis alvos para renomeações/cópia.  Esta opção impede que
a detecção da ação de renomear/cópia seja executada se a quantidade dos
alvos a serem renomeados/copiados exceda o a quantidade especificada.
 --diff-filter=[(A|C|D|M|R|T|U|X|B)…​[*]] 
Selecione apenas os arquivos Adicionados (A), Copiados (C), Excluídos
(D), Modificados (M), Renomeados (R) e que tenham o seu tipo (por
exemplo, arquivo normal, link simbólico, o submódulo, …​) alterado (T),
não está mesclado (U), que seja desconhecido (X) ou que teve o seu
emparelhamento quebrado (B).  Qualquer combinação dos caracteres do filtro
(incluindo none nenhum) pode ser utilizado.  Quando * (Tudo ou nenhum) é
adicionado à combinação, todos os caminhos são selecionados caso haja algum
arquivo que coincida com outros critérios durante a comparação; caso não
haja nenhum arquivo que coincida com outros critérios, nada será
selecionado.
Além disso, estas letras maiúsculas podem ser transformadas em minusculas
para se excluir.  --diff-filter=ad exclui os caminhos adicionados e
excluídos por exemplo.
Observe que nem todas as diferenças diff podem apresentar todos os
tipos. Por exemplo, diffs do índice para a árvore de trabalho nunca podem
ter entradas adicionadas (porque o conjunto dos caminhos inclusos no diff é
limitado pelo que está no índice).  Da mesma forma, as entradas copiadas e
renomeadas não podem aparecer caso a detecção para estes tipos estiverem
desativados.
 -S&lt;texto&gt; 
Procure por diferenças que alterem a quantidade de ocorrências da cadeia de
caracteres especificada (ou seja, adição/exclusão) em um arquivo.  Destinado
ao uso do scripter.
Útil durante a produra por um bloco de código exato (como uma "struct"), e
quera saber o histórico deste bloco desde que ele surgiu: utilize o recurso
de forma iterativa para alimentar o bloco de interesse na pré-imagem de
volta -S e continue até você obter a primeira versão do bloco.
Os arquivos binários também são pesquisados.
 -G&lt;expressão-regular&gt; 
Procure por diferenças cujo texto do patch contenha as linhas
adicionadas/removidas que correspondam a um &lt;expressão-regular&gt;.
Para ilustrar a diferença entre -S&lt;expressão-regular&gt; --pickaxe-regex e
-G&lt;expressão-regular&gt;, considere um commit com o seguinte diff no mesmo
arquivo:
+    return frotz(nitfol, two-&gt;ptr, 1, 0);
...
-    hit = frotz(nitfol, mf2.ptr, 1, 0);
Enquanto o git log -G"frotz\(nitfol" exibirá este commit, já o git log
-S"frotz\(nitfol" --pickaxe-regex não (porque a quantidade de ocorrências
dessa cadeia de caracteres não foi alterada) .
A menos que --text seja utilizado, os patches dos arquivos binários sem um
filtro "textconv" serão ignorados.
Para mais informações consulte a entrada pickaxe em
gitdiffcore[7].
 --find-object=&lt;id-do-objeto&gt; 
Procure pelas diferenças que alteram a quantidade de ocorrências do objeto
especificado. Similar ao -S, porém apenas o argumento é diferente pois ele
não procura por uma sequência específica, mas por um ID específico do
objeto.
O objeto pode ser uma bolha ou um commit do submódulo. Para também encontrar
árvores, faça a utilização da opção -t também no git-log.
 --pickaxe-all 
Quando a opção -S ou -G encontra uma alteração, exiba todas as
alterações naquele conjunto de alterações e não apenas nos arquivos que
contenham as alterações em uma &lt;texto&gt;.
 --pickaxe-regex 
Trate o &lt;texto&gt; utilizado com o -S como uma expressão regular POSIX
estendida para coincidir.
 -O&lt;ordem-do-arquivo&gt; 
Controlar a ordem em que os arquivos aparecem na saída.  Substitui a
variável de configuração diff.orderFile (consulte git-config[1]).
Para cancelar a variável diff.orderFile, utilize -O/dev/null.
A ordem da saída é determinada pela ordem dos padrões bolha na
&lt;ordem-do-arquivo&gt;.  São enviados primeiro todos os arquivos cujos nomes do
caminho coincidam com o primeiro padrão, em seguida todos os arquivos cujos
nomes do caminho coincidam com o segundo padrão (mas não ao primeiro) e
assim por diante.  São exibidos por último todos os arquivos cujos nomes do
caminho não coincidam com nenhum padrão como se houvesse um padrão de
coincidência total implícito no final do arquivo.  Caso vários nomes do
caminho tenham a mesma classificação (eles coincidem com o mesmo padrão, mas
não com os padrões anteriores), a sua ordem na saída em relação à outra é a
ordem normal.
A &lt;ordem-do-arquivo&gt; é analisado da seguinte maneira:
As linhas em branco são ignoradas para que possam ser utilizadas como
separadores, facilitando a leitura.
As linhas que começam com um hash ("#") são ignoradas para que possam ser
utilizadas como comentários.  Adicione uma barra invertida ("\") ao início
do padrão caso ele comece com um hash.
Cada outra linha quem contenha um único padrão.
Os padrões têm a mesma sintaxe e semântica que os padrões utilizados para
fnmatch(3) sem a flag FNM_PATHNAME, exceto que um nome do caminho também
coincida com um padrão caso a remoção de qualquer quantidade dos componentes
finais do nome do caminho coincida com o padrão.  O padrão "foo*bar"
coincide com "fooasdfbar" e "foo/bar/baz/asdf" mas não com "foobarx"
por exemplo.
 -R 
Troque as duas entradas; isto é, exiba as diferenças do índice ou do arquivo
no disco para o conteúdo da árvore.
 --relative[=&lt;caminho&gt;] 
 --no-relative 
Com esta opção, quando executado a partir de um subdiretório do projeto,
pode-se dizer para excluir as alterações fora do diretório e exibir os nomes
do caminho relativos a ele.  Quando não estiver em um subdiretório (em um
repositório simples por exemplo), é possível nomear em qual subdiretório
tornar a saída relativa, utilizando um &lt;caminho&gt; como argumento. A opção
--no-relative pode ser utilizada para contrapor ambas as opções de
configuração diff.relative e a anterior --relative.
 -a 
 --text 
Trate todos os arquivos como texto.
 --ignore-cr-at-eol 
Ignore o retorno do carro no final da linha durante uma comparação.
 --ignore-space-at-eol 
Ignore as alterações no espaço na EOL (fim da linha).
 -b 
 --ignore-space-change 
Ignore as alterações na quantidade do espaço.  Ignora o espaço no final da
linha e considera todas as outras sequências de um ou mais caracteres de
espaço como equivalentes.
 -w 
 --ignore-all-space 
Ignore o espaço durante a comparação das linhas.  Ignore as diferenças mesmo
que uma linha tenha espaços quando a outra linha não tiver nenhuma.
 --ignore-blank-lines 
Ignore as alterações cujas linhas estejam todas em branco.
 --inter-hunk-context=&lt;linhas&gt; 
Exiba o contexto entre as diferenças, até a quantidade de linhas
especificada, fundindo assim as que estão próximas umas das outras.  A
predefinição retorna para diff.interHunkContext ou 0 caso a opção de
configuração não esteja definida.
 -W 
 --function-context 
Exiba todas as funções ao redor das alterações.
 --exit-code 
Faça com que o programa encerre com códigos semelhantes ao diff(1).  Ou
seja, encerra com 1 caso haja diferenças ou 0 quando não houver.
 --quiet 
Faz com que o programa trabalhe em silêncio. Implica no uso da opção
--exit-code.
 --ext-diff 
Permitir que um auxiliar diff externo seja executado. Caso um controlador
diff externo seja definido com gitattributes[5], será necessário a
utilização desta opção com git-log[1] e seus companheiros.
 --no-ext-diff 
Não permitir o uso de um controladores diff externo.
 --textconv 
 --no-textconv 
Permita (ou não permita) a execução dos filtros externos para a conversão do
texto durante a comparação dos arquivos binários. Para mais detalhes
consulte gitattributes[5]. Como os filtros "textconv" são
normalmente uma conversão unidirecional, o diff resultante é legível para as
pessoas porém não pode ser aplicado. Por este motivo, é predefinido que os
filtros "textconv" estejam ativos apenas para os comandos
git-diff[1] e git-log[1], mas não para os comandos
git-format-patch[1] ou comandos "diff" que possam ser
redirecionados.
 --ignore-submodules[=&lt;quando&gt;] 
Ignore as alterações nos submódulos durante a geração dos diffs. O
&lt;quando&gt; pode ser "none" (nenhum), "untracked" (sem
monitoramento/rastreamento), "dirty" (sujo) ou "all" (todos), que é a
predefinição.  O "none" considera o submódulo modificado quando houver
arquivos não estejam rastreados, modificados ou o seu HEAD seja diferente
do commit registrado no superprojeto, pode ser utilizado para substituir
qualquer configuração da opção ignore (ignorar) em  git-config[1]
ou gitmodules[5]. Quando o "untracked" é utilizado, os submódulos
não são considerados sujos quando houver apenas  um conteúdo sem
rastreamento (porém o monitoramento de alterações do seu conteúdo continua)
O uso de "dirty" ignora todas as alterações na árvore de trabalho dos
submódulos, apenas as alterações nos commits armazenados no superprojeto são
exibidos (este era o comportamento anterior até a versão 1.7.0). O uso de
"all" oculta todas as alterações nos submódulos.
 --src-prefix=&lt;prefixo&gt; 
Exiba o prefixo da origem utilizada em vez de "a/".
 --dst-prefix=&lt;prefixo&gt; 
Exiba o prefixo do destino utilizado em vez de "b/".
 --no-prefix 
Não exiba nenhum prefixo da origem ou destino.
 --line-prefix=&lt;prefixo&gt; 
Prefira um prefixo adicional em cada linha produzida.
 --ita-invisible-in-index 
É predefinido que as entradas adicionadas através do comando "git add -N"
apareçam como uma cadeia de caracteres vazia existente com o comando "git
diff" e um novo arquivo com "git diff --cached".  Esta opção faz com que a
entrada apareça como um novo arquivo no "git diff" e inexistente no "git
diff --cached". Esta opção pode ser revertida com
--ita-visible-in-index. Ambas as opções são experimentais e podem ser
removidas no futuro.
Para uma explicação mais detalhada sobre estas opções comuns, consulte
também gitdiffcore[7].
 -1 --base 
 -2 --ours 
 -3 --theirs 
Compare a árvore de trabalho com a versão "base" (stage #1), "o nosso ramo"
(stage #2) "o ramo deles" (stage #3).  O índice contém estas etapas apenas
para as entradas que não foram não mescladas enquanto estiver resolvendo os
conflitos.  Para obter informações mais detalhadas, consulte a seção "3-Way
Merge" git-read-tree[1].
 -0 
Omita a saída diff para as entradas que não tenham sido mescladas e exiba
"Unmergedd".  Só pode ser utilizado quando comparamos a árvore de trabalho
com o índice.
 &lt;caminho&gt;…​ 
Os parâmetros &lt;paths&gt;, quando utilizados, são para limitar o diff quanto
aos nomes dos caminhos (você pode dar nomes de diretórios e obter um diff
para todos os arquivos sob eles).
Gerando o formato bruto
O formato bruto gerado com os comandos "git-diff-index", "git-diff-tree",
"git-diff-files" e "git diff --raw" são muito parecidos.
Todos estes comandos comparam dois conjuntos de coisas; o que é comparado
difere de:
 git-diff-index &lt;tree-ish&gt; 
compara o &lt;tree-ish&gt; e os arquivos no sistema de arquivos.
 git-diff-index --cached &lt;tree-ish&gt; 
compara o &lt;tree-ish&gt; e o índice.
 git-diff-tree [-r] &lt;tree-ish-1&gt; &lt;tree-ish-2&gt; [&lt;padrão&gt;…​] 
compara as árvores citadas pelos dois argumentos.
 git-diff-files [&lt;padrão&gt;…​] 
compara o índice e os arquivos no sistema de arquivos.
O comando "git-diff-tree" inicia a sua saída imprimindo o hash do que está
sendo comparado. Depois disso, todos os comandos imprimem uma linha na saída
por arquivo modificado.
A linha na saída é formatada da seguinte maneira:
edição no local  :100644 100644 bcd1234 0123456 M   arquivo0
copiar editar    :100644 100644 abcd123 1234567 C68 arquivo1 arquivo2
renomear editar  :100644 100644 abcd123 1234567 R86 arquivo1 arquivo3
criar            :000000 100644 0000000 1234567 A   arquivo4
excluir          :100644 000000 1234567 0000000 D   arquivo5
não mesclado     :000000 000000 0000000 0000000 U   arquivo6
Ou seja, da esquerda para a direita:
dois pontos.
Um modo para "src"; 000000 caso seja criado ou não mesclado.
um espaço.
O modo para "dst"; 000000 caso seja excluído ou não mesclado.
um espaço.
sha1 para "src"; 0{40} caso seja criado ou não mesclado.
um espaço.
sha1 para "dst"; 0{40} caso seja criado, não mesclado ou "consultar a
árvore de trabalho".
um espaço.
status, seguido pelo número "score" opcional.
uma aba ou um NUL quando a opção -z é utilizada.
path para "src"
uma aba ou um NUL quando a opção -z é utilizada; existe apenas para C ou
R.
path para "dst"; existe apenas para C ou R.
um LF ou um NUL quando a opção -z é utilizada para finalizar o registro.
As possíveis letras que exibem a condição são:
A: a adição de um arquivo
C: a cópia de um arquivo para um novo
D: a exclusão de um arquivo
M: a modificação do conteúdo ou do modo de um arquivo
R: uma renomeação de um arquivo
T: altera o tipo do arquivo
U: o arquivo está sem mesclagem (você deve concluir a mesclagem antes que o
commit possa ser feito)
X: um tipo de alteração "desconhecida" (provavelmente um bug, por favor
denuncie)
As letras de condição C e R sempre são seguidas por uma pontuação (indicando
a porcentagem da semelhança entre a origem e o destino da movimentação ou da
cópia).  A letra de condição M pode ser seguida por uma pontuação (denotando
a porcentagem de dissimilaridade) para reescrever os arquivos.
O &lt;sha1&gt; é exibido zerado caso um arquivo seja novo no sistema de arquivos e
esteja fora de sincronia com o índice.
Exemplo:
:100644 100644 5be4a4a 0000000 M file.c
Sem a opção z, os pathnames com os caracteres "incomuns" são citados
conforme explicado na variável de configuração core.quotePath (consulte
git-config[1]).  Utilizando a opção -z, o nome do arquivo é gerado
literalmente e a linha é finalizada com um byte NUL.
O formato diff para as mesclagens
Os comandos "git-diff-tree", "git-diff-files" e "git-diff --raw" podem
utilizar as opções -c ou --cc para também gerar uma saída "diff" com os
commits mesclados.  A saída difere do formato descrito acima da seguinte
maneira:
há dois pontos para cada origem
existem mais modos "src" e "src" sha1
a condição é concatenada como uma condição dos caracteres para cada origem
sem um número "score" opcional
os caminho(s) separado(s) por tabulações do arquivo
Para as opções -c e --cc apenas o destino ou o caminho final é exibido
ainda que o arquivo tenha sido renomeado em qualquer parte do histórico.
Com a opção --combined-all-paths, o nome do caminho em cada origem é
exibido seguido pelo nome do caminho durante a mesclagem do commit.
Exemplos para as opções -c e --cc sem utilizar a opção
--combined-all-paths:
::100644 100644 100644 fabadb8 cc95eb0 4866510 MM	desc.c
::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM	bar.sh
::100644 100644 100644 e07d6c5 9042e82 ee91881 RR	phooey.c
Exemplos quando a opção --combined-all-paths é adicionado entre -c ou
--cc:
::100644 100644 100644 fabadb8 cc95eb0 4866510 MM	desc.c	desc.c	desc.c
::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM	foo.sh	bar.sh	bar.sh
::100644 100644 100644 e07d6c5 9042e82 ee91881 RR	fooey.c	fuey.c	phooey.c
Note que o diff combinado lista apenas os arquivos que foram alterados em
todas as origems.
Gerando a correção em um formato texto com a opção -p
Executando git-diff[1], git-log[1], git-show[1],
git-diff-index[1], git-diff-tree[1], ou
git-diff-files[1] com a opção -p produz um patch em formato
texto.  É possível personalizar a criação do patch em um formato texto
através das variáveis de ambiente GIT_EXTERNAL_DIFF e GIT_DIFF_OPTS.
O que a opção -p produz é um pouco diferente do formato diff tradicional:
Ele é precedido por um cabeçalho "git diff" que se parece com:
diff --git a/arquivo1 b/arquivo2
Os nomes dos arquivos a/ e b/ são os mesmos a menos que haja uma
renomeação ou cópia.  Especialmente para uma criação ou exclusão,
/dev/null não é utilizado no lugar dos nomes do arquivo a/ ou b/.
Quando há um envolvimento no processo de renomear ou copiar, arquivo1 e
arquivo2 exibem o nome do arquivo de origem da renomeação ou cópia e o
nome do arquivo produzido pela renomeação ou copia respectivamente.
É seguido por uma ou mais linhas estendidas do cabeçalho:
modo antigo               &lt;modo&gt;
modo novo                 &lt;modo&gt;
modo de arquivo excluído  &lt;modo&gt;
novo modo de arquivo      &lt;modo&gt;
copiar de                 &lt;caminho&gt;
copiar para               &lt;caminho&gt;
renomear de               &lt;caminho&gt;
renomear para             &lt;caminho&gt;
índice de similaridade    &lt;quantidade&gt;
índice de dissimilaridade &lt;quantidade&gt;
índice                    &lt;hash&gt;..&lt;hash&gt; &lt;modo&gt;
Os modos dos arquivo são impressos como números octais com 6 dígitos,
incluindo o tipo do arquivo e dos bits de permissão do arquivo.
Os nomes do caminho nos cabeçalhos estendidos não incluem os prefixos a/ e
b/.
O índice de similaridade é a porcentagem das linhas inalteradas e o índice
de dissimilaridade é a porcentagem das linhas alteradas.  É um número
inteiro arredondado, seguido por um sinal de porcentagem.  O valor do índice
de similaridade de 100% é reservado para dois arquivos iguais, enquanto a
dissimilaridade de 100% significa que nenhuma linha do arquivo antigo chegou
ao novo.
A linha do índice inclui os nomes dos objetos bolha antes e depois da
alteração.  O &lt;modo&gt; será incluído caso o modo do arquivo não seja
alterado; caso contrário, linhas separadas indicam o modo antigo e o novo.
Os nomes dos caminhos com caracteres "incomuns" são citados como já
explicado na variável de configuração core.quotePath (consulte
git-config[1]).
Todos os arquivos arquivo1 na saída se referem aos arquivos antes do
commit e todos os arquivos arquivo2 se referem aos arquivos após o
commit.  É incorreto aplicar cada alteração em cada arquivo
sequencialmente.  Por exemplo, este patch irá substituir a e b:
diff --git a/a b/b
renomeie a partir de a
renomeie para b
diff --git a/b b/a
renomeie a partir do b
renomeie para a
O formato diff combinado
Qualquer comando que gere um diff pode utilizar a opção -c ou --cc para
produzir um diff combinado ao exibir uma mesclagem. Este é o formato
predefinido durante a exibição das mesclagens com git-diff[1] or
git-show[1]. Observe também que é possível utilizar a opção -m com
qualquer um destes comandos para impor a geração dos diffs com as origens
individuais de uma mesclagem.
Um formato "diff combinado" fica assim:
diff --combined describe.c
index fabadb8,cc95eb0..4866510
--- a/describe.c
+++ b/describe.c
@@@ -98,20 -98,12 +98,20 @@@
	return (a_date &gt; b_date) ? -1 : (a_date == b_date) ? 0 : 1;
  }
- static void describe(char *arg)
 -static void describe(struct commit *cmit, int last_one)
++static void describe(char *arg, int last_one)
  {
 +	unsigned char sha1[20];
 +	struct commit *cmit;
	struct commit_list *list;
	static int initialized = 0;
	struct commit_name *n;
 +	if (get_sha1(arg, sha1) &lt; 0)
 +		usage(describe_usage);
 +	cmit = lookup_commit_reference(sha1);
 +	if (!cmit)
 +		usage(describe_usage);
 +
	if (!initialized) {
		initialized = 1;
		for_each_ref(get_name);
Ele é precedido por um cabeçalho "git diff" parecido com este (quando a
opção -c é utilizada):
diff --combined arquivo
ou assim (quando a opção --cc é utilizada):
diff --cc arquivo
Ele é seguido por uma ou mais linhas estendidas do cabeçalho (este exemplo
exibe uma mesclagem com duas origens):
índice &lt;hash&gt;,&lt;hash&gt;..&lt;hash&gt;
modo &lt;modo&gt;,&lt;modo&gt;..&lt;modo&gt;
modo novo arquivo &lt;modo&gt;
modo arquivo excluído &lt;modo&gt;,&lt;modo&gt;
A linha modo &lt;modo&gt;,&lt;modo&gt;..&lt;modo&gt; aparece apenas caso pelo menos um dos
&lt;modos&gt; seja diferente do restante. Os cabeçalhos estendidos com informações
sobre a movimentação do conteúdo detectado (renomeação e detecção da cópia)
são projetados para trabalhar com o diff com dois &lt;tree-ish&gt; e não são
utilizados pelo formato diff combinado.
É seguido por duas linhas do cabeçalho do arquivo/para o arquivo
--- a/arquivo
+++ b/arquivo
Semelhante ao cabeçalho de duas linhas para o formato diff tradicional
unificado, o /dev/null é utilizado para sinalizar os arquivos criados ou
excluídos.
No entanto, caso a opção --combined-all-paths seja utilizada, em vez de
duas linhas do arquivo/para o arquivo, será obtido um cabeçalho N+1 do
cabeçalho do arquivo de "origem" para o arquivo de "destino" onde N é a
quantidade de origens na mesclagem do commit
--- a/arquivo
--- a/arquivo
--- a/arquivo
+++ b/arquivo
Este formato estendido pode ser útil caso a detecção da renomeação ou cópia
esteja ativa, permitindo que você veja o nome original do arquivo em
diferentes origens.
O formato do cabeçalho do pedaço é modificado para prevenir que as pessoas o
alimentem acidentalmente com patch -p1. O formato diff combinado foi
criado para revisar as alterações da mesclagem dos commits e não era para
ser aplicado. A alteração é semelhante a alteração no cabeçalho estendido do
índice:
@@@ &lt;from-file-range&gt; &lt;from-file-range&gt; &lt;to-file-range&gt; @@@
Existem (a quantidade de origens + 1) caracteres @ no cabeçalho do bloco
para o formato diff combinado.
Diferente do formato diff unificado tradicional que exiba os dois arquivos
A e B com uma única coluna que possua o sinal de menos - (o sinal de menos — aparece em A mas é removido em B), + (o sinal de mais — ausente em A,
mas adicionado em B), ou o prefixo " " (sem alteração — de espaço), este
formato compara dois ou mais arquivos arquivo1, arquivo2, …​ com um arquivo
X e exibe como X difere de cada arquivoN.  Uma coluna para cada arquivoN é
anexada à linha de saída para observar como a linha de X é diferente dela.
Um caractere - na coluna N significa que a linha aparece no "arquivoN",
mas não aparece no resultado.  Um caractere + na coluna N significa que a
linha aparece no resultado e o arquivoN não possui essa linha (em outras
palavras, a linha foi adicionada, do ponto de vista dessa origem).
Na saída do exemplo acima, a assinatura da função foi alterada nos dois
arquivos (portanto, duas remoções - do arquivo1 e do arquivo2, mais ++
significa que uma linha que foi adicionada não aparece no arquivo1 ou no
arquivo2).  Outras oito linhas também são iguais no arquivo1, mas não
aparecem no arquivo2 (portanto, prefixadas com +).
Quando exibido pelo comando git diff-tree -c, compara as origens de um
commit mesclado com o resultado da mesclagem (ou seja, arquivo1..arquivoN
são as origens).  Quando exibido pelo comando git diff-files -c, as duas
origens com as suas respectivas mesclagens não resolvidas com o arquivo da
árvore de trabalho (ou seja, arquivo1 é o estágio 2, informado como "nossa
versão", o arquivo2 é o estágio 3, informado como "a versão deles").
Outros formatos diff
A opção --summary descreve os arquivos adicionados, excluídos, renomeados
e copiados recentemente.  A opção --stat adiciona o grafo diffstat(1) à
saída.  Estas opções podem ser combinadas com outras opções como -p, que
são legíveis para nós.
Ao exibir uma alteração que envolva uma renomeação ou uma cópia, a saída do
comando --stat formata os nomes do caminho de forma compacta combinando o
prefixo e sufixo comum aos nomes do caminho.  Uma alteração que mova
arch/i386/Makefile para arch/x86/Makefile enquanto modifica as 4 linhas
será exibido assim:
arch/{i386 =&gt; x86}/Makefile    |   4 +--
A opção --numstat fornece as informações diffstat(1), foi projetada para
facilitar o consumo da máquina.  Uma entrada na saída --numstat fica
assim:
1	2	README
3	1	arch/{i386 =&gt; x86}/Makefile
Ou seja, da esquerda para a direita:
a quantidade das linhas que foram adicionadas;
um separador;
a quantidade de linhas que foram excluídas;
um separador;
nome do caminho (possivelmente com informações para renomear ou copiar);
uma nova linha.
Quando a opção de saída -z está em vigor, a saída é formatada desta
maneira:
1	2	README NUL
3	1	NUL arch/i386/Makefile NUL arch/x86/Makefile NUL
Isso é:
a quantidade das linhas que foram adicionadas;
um separador;
a quantidade de linhas que foram excluídas;
um separador;
um NUL (apenas existe caso seja renomeado ou copiado);
nome do caminho na pré-imagem;
um NUL (apenas existe caso seja renomeado ou copiado);
nome do caminho na pós-imagem (só existe se for renomeado ou copiado);
um NUL.
O NUL extra antes do caminho da pré-imagem é renomeado para permitir que
os scripts que leem a saída digam se o registro atual que está sendo lido é
um registro do caminho único ou um nome para a renomeação ou cópia sem fazer
a leitura adiante.  Depois de ler as linhas adicionadas e excluídas, a
leitura até o NUL produziria o nome do caminho, mas caso seja um NUL, o
registro exibirá dois caminhos.
EXEMPLOS
 Várias maneiras para verificar a sua árvore de trabalho 
$ git diff            (1)
$ git diff --cached   (2)
$ git diff HEAD       (3)
As mudanças na árvore de trabalho ainda não preparadas para o próximo
commit.
As alterações entre o índice e o seu último commit; o que você estaria
fazendo no commit caso você executasse o comando "git commit" sem a opção
"-a".
As alterações na árvore de trabalho desde o seu último commit; o que você
estaria fazendo no commit caso executasse o comando "git commit -a"
 Comparando com commits arbitrários 
$ git diff test            (1)
$ git diff HEAD -- ./test  (2)
$ git diff HEAD^ HEAD      (3)
Em vez de utilizar o cume do ramo atual, compare com o cume do ramo "teste".
Em vez de comparar com o cume do ramo "teste", compare com o cume do ramo
atual, limitando-se a comparação com o arquivo "teste".
Compare a versão antes do último commit e o último commit.
 Comparando os ramos 
$ git diff topic master    (1)
$ git diff topic..master   (2)
$ git diff topic...master  (3)
As alterações entre as dicas do tópico e as ramificações principais.
O mesmo que acima.
As alterações que ocorreram na ramificação master (mestre) desde quando a
ramificação do tópico foi iniciada.
 Limitando a saída diff 
$ git diff --diff-filter=MRC            (1)
$ git diff --name-status                (2)
$ git diff arch/i386 include/asm-i386   (3)
Exibe apenas as modificações, renomeações e cópias, mas não a adição ou
exclusão.
Exibe apenas os nomes e a natureza da alteração, mas não a saída diff real.
Limite a saída diff aos nomes das subárvores.
 Arruinando a saída diff 
$ git diff --find-copies-harder -B -C  (1)
$ git diff -R                          (2)
Gaste alguns ciclos extras para encontrar renomeações, cópias e reescritas
completas (muito custoso ao sistema).
Saída do diff em reverso.
VEJA TAMBÉM
diff(1), git-difftool[1], git-log[1],
gitdiffcore[7], git-format-patch[1], git-apply[1],
git-show[1]
GIT
Parte do conjunto git[1]
    About this site
    Patches, suggestions, and comments are welcome.
    Git is a member of Software Freedom Conservancy
