        About
            Branching and Merging
            Small and Fast
            Distributed
            Data Assurance
            Staging Area
            Free and Open Source
            Trademark
        Documentation
            Reference
            Book
            Videos
            External Links
        Downloads
            GUI Clients
            Logos
        Community
This book is available in
  English.
  Full translation available in
    български език,
    Deutsch,
    Español,
    Français,
    Ελληνικά,
    日本語,
    한국어,
    Nederlands,
    Русский,
    Slovenščina,
    Tagalog,
    Українська
    简体中文,
  Partial translations available in
    Čeština,
    Македонски,
    Polski,
    Српски,
    Ўзбекча,
    繁體中文,
  Translations started for
    azərbaycan dili,
    Беларуская,
    فارسی,
    Indonesian,
    Italiano,
    Bahasa Melayu,
    Português (Brasil),
    Português (Portugal),
    Svenska,
    Türkçe.
The source of this book is  hosted on GitHub.
Patches, suggestions and comments are welcome.
  Chapters ▾
  1. 시작하기
          1.1
          버전 관리란? 
          1.2
          짧게 보는 Git의 역사 
          1.3
          Git 기초 
          1.4
          CLI 
          1.5
          Git 설치 
          1.6
          Git 최초 설정 
          1.7
          도움말 보기 
          1.8
          요약 
  2. Git의 기초
          2.1
          Git 저장소 만들기 
          2.2
          수정하고 저장소에 저장하기 
          2.3
          커밋 히스토리 조회하기 
          2.4
          되돌리기 
          2.5
          리모트 저장소 
          2.6
          태그 
          2.7
          Git Alias 
          2.8
          요약 
  3. Git 브랜치
          3.1
          브랜치란 무엇인가 
          3.2
          브랜치와 Merge 의 기초 
          3.3
          브랜치 관리 
          3.4
          브랜치 워크플로 
          3.5
          리모트 브랜치 
          3.6
          Rebase 하기 
          3.7
          요약 
  4. Git 서버
          4.1
          프로토콜 
          4.2
          서버에 Git 설치하기 
          4.3
          SSH 공개키 만들기 
          4.4
          서버 설정하기 
          4.5
          Git 데몬 
          4.6
          스마트 HTTP 
          4.7
          GitWeb 
          4.8
          GitLab 
          4.9
          또 다른 선택지, 호스팅 
          4.10
          요약 
  5. 분산 환경에서의 Git
          5.1
          분산 환경에서의 워크플로 
          5.2
          프로젝트에 기여하기 
          5.3
          프로젝트 관리하기 
          5.4
          요약 
  6. GitHub
          6.1
          계정 만들고 설정하기 
          6.2
          GitHub 프로젝트에 기여하기 
          6.3
          GitHub 프로젝트 관리하기 
          6.4
          Organization 관리하기 
          6.5
          GitHub 스크립팅 
          6.6
          요약 
  7. Git 도구
          7.1
          리비전 조회하기 
          7.2
          대화형 명령 
          7.3
          Stashing과 Cleaning 
          7.4
          내 작업에 서명하기 
          7.5
          검색 
          7.6
          히스토리 단장하기 
          7.7
          Reset 명확히 알고 가기 
          7.8
          고급 Merge 
          7.9
          Rerere 
          7.10
          Git으로 버그 찾기 
          7.11
          서브모듈 
          7.12
          Bundle 
          7.13
          Replace 
          7.14
          Credential 저장소 
          7.15
          요약 
  8. Git맞춤
          8.1
          Git 설정하기 
          8.2
          Git Attributes 
          8.3
          Git Hooks 
          8.4
          정책 구현하기 
          8.5
          요약 
  9. Git과 여타 버전 관리 시스템
          9.1
          Git: 범용 Client 
          9.2
          Git으로 옮기기 
          9.3
          요약 
  10. Git의 내부
          10.1
          Plumbing 명령과 Porcelain 명령 
          10.2
          Git 개체 
          10.3
          Git Refs 
          10.4
          Packfile 
          10.5
          Refspec 
          10.6
          데이터 전송 프로토콜 
          10.7
          운영 및 데이터 복구 
          10.8
          환경변수 
          10.9
          요약 
  A1. Appendix A: 다양한 환경에서 Git 사용하기
          A1.1
          GUI 
          A1.2
          Visual Studio 
          A1.3
          Eclipse 
          A1.4
          Bash 
          A1.5
          Zsh 
          A1.6
          Git in Powershell 
          A1.7
          요약 
  A2. Appendix B: 애플리케이션에 Git 넣기
          A2.1
          Git 명령어 
          A2.2
          Libgit2 
          A2.3
          JGit 
          A2.4
          go-git 
  A3. Appendix C: Git 명령어
          A3.1
          설치와 설정 
          A3.2
          프로젝트 가져오기와 생성하기 
          A3.3
          스냅샷 다루기 
          A3.4
          Branch와 Merge 
          A3.5
          공유하고 업데이트하기 
          A3.6
          보기와 비교 
          A3.7
          Debugging 
          A3.8
          Patch 하기 
          A3.9
          Email 
          A3.10
          다른 버전 관리 시스템 
          A3.11
          관리 
          A3.12
          Plumbing 명령어 
      2nd Edition
    7.6 Git 도구 - 히스토리 단장하기
히스토리 단장하기
Git으로 일하다 보면 어떤 이유로든 로컬 커밋 히스토리를 수정해야 할 때가 있다.
결정을 나중으로 미룰 수 있던 것은 Git의 장점이다.
Staging Area로 커밋할 파일을 고르는 일을 커밋하는 순간으로 미룰 수 있고 Stash 명령으로 하던 일을 미룰 수 있다. 게다가 이미 커밋해서 결정한 내용을 수정할 수 있다. 그리고 수정할 수 있는 것도 매우 다양하다.
커밋들의 순서도 변경할 수 있고 커밋 메시지와 커밋한 파일도 변경할 수 있다. 여러 개의 커밋을 하나로 합치거나 반대로 커밋 하나를 여러 개로 분리할 수도 있다. 아니면 커밋 전체를 삭제할 수도 있다. 하지만, 이 모든 것은 다른 사람과 코드를 공유하기 전에 해야 한다.
이 절에서는 사람들과 코드를 공유하기 전에 커밋 히스토리를 예쁘게 단장하는 방법에 대해서 설명한다.
Note
Git이 동작하는 기본 원리 중 하나는 Git은 로컬에 모든 버전관리 데이터를 로컬에 복사(Clone) 해두고 있다는 점이다. 이 때문에 자유롭게 히스토리를 로컬에서 수정해 볼 수 있는 자유도 누릴 수 있다.
다만 로컬의 버전관리 데이터 혹은 커밋이 외부로 Push가 된 후라면 이야기는 완전 딴판이된다. Push된 데이터는 수정에 대해선 완전이 끝난 것이다. 고쳐야 할 이유가 생겼더라도 새로 수정작업을 추가해야지 이전 커밋 자체를 수정할 수는 없다.
그렇기에 온전하게 수정 작업을 마무리했다는 확신 없이 작업 내용을 공유하는 저장소로 보내는(Push) 것은 피해야 할 행동이다.
마지막 커밋을 수정하기
히스토리를 단장하는 일 중에서는 마지막 커밋을 수정하는 것이 가장 자주 하는 일이다.
기본적으로 두 가지로 나눌 수 있는데 하나는 단순히 커밋 메시지만를 수정하는 것이고 다른 하나는 나중에 수정한 파일을 마지막 커밋 안에 밀어넣는 것이다.
커밋 메시지를 수정하는 방법은 매우 간단하다.
$ git commit --amend
이 명령은 자동으로 텍스트 편집기를 실행시켜서 마지막 커밋 메시지를 열어준다.
여기에 메시지를 바꾸고 편집기를 닫으면 편집기는 바뀐 메시지로 마지막 커밋을 수정한다.
반대로 커밋 메시지가 아니라 프로젝트 내용을 수정한 경우가 있다. 커밋하고 난 후 새로 만든 파일이나 수정한 파일을 가장 최근 커밋에 집어넣을 수 있다. 기본적으로 방법은 같다.
파일을 수정하고 git add 명령으로 Staging Area에 넣는다. 그리고 git commit --amend 명령으로 커밋하면 커밋 자체가 수정되면서 추가로 수정사항을 밀어넣을 수 있다.
이때 SHA-1 값이 바뀌기 때문에 과거의 커밋을 변경할 때 주의해야 한다.
Rebase와 같이 이미 Push 한 커밋은 수정하면 안 된다.
Tip
커밋을 고치는 작업은 커밋 메시지 고치를 덩달아 이끌 수 있음
커밋을 고치는 것은 커밋 메시지를 고치는 것일수도 있고 또는 커밋 담고 있는 변경 내용을 고치는 것 일수도 있다.
커밋의 고치는데 있어 추가된 변경 내용이 상당히 있을 경우 커밋 메시지가 충실하게 담고 있는지 확인해 볼 필요가 있다.
반대로 커밋을 고치는 내용이 오타를 살짝 고치거나 실수로 빠뜨린 것을 넣는 등 아주 사소하거나 이미 커밋 메시지가 충분히 이를 반영하고 있을 수 있다. 이런 경우 다음과 같이 --no-edit 옵션을 사용하면 커밋 메시지를 수정하도록 편집기가 실행되지는 않는다.
$ git commit --amend --no-edit
커밋 메시지를 여러 개 수정하기
최근 커밋이 아니라 예전 커밋을 수정하려면 다른 도구가 필요하다.
히스토리 수정하기 위해 만들어진 도구는 없지만 rebase 명령을 이용하여 수정할 수 있다. 현재 작업하는 브랜치에서 각 커밋을 하나하나 수정하는 것이 아니라 어느 시점부터 HEAD까지의 커밋을 한 번에 Rebase 한다.
대화형 Rebase 도구를 사용하면 커밋을 처리할 때마다 잠시 멈춘다. 그러면 각 커밋의 메시지를 수정하거나 파일을 추가하고 변경하는 등의 일을 진행할 수 있다.
git rebase 명령에 -i 옵션을 추가하면 대화형 모드로 Rebase 할 수 있다.
어떤 시점부터 HEAD까지 Rebase 할 것인지 인자로 넘기면 된다.
마지막 커밋 메시지 세 개를 모두 수정하거나 그 중 몇 개를 수정하는 시나리오를 살펴보자. git rebase -i 의 인자로 편집하려는 마지막 커밋의 부모를 `HEAD~2^`나 `HEAD~3`로 해서 넘긴다.
마지막 세 개의 커밋을 수정하는 것이기 때문에 `~3`이 좀 더 기억하기 쉽다. 그렇지만, 실질적으로 가리키게 되는 것은 수정하려는 커밋의 부모인 네 번째 이전 커밋이다.
$ git rebase -i HEAD~3
이 명령은 Rebase 하는 것이기 때문에 메시지의 수정 여부에 관계없이 HEAD~3..HEAD 범위에 있는 모든 커밋을 수정한다.
다시 강조하지만 이미 중앙서버에 Push 한 커밋은 절대 고치지 말아야 한다. Push 한 커밋을 Rebase 하면 결국 같은 내용을 두 번 Push 하는 것이기 때문에 다른 개발자들이 혼란스러워 할 것이다.
실행하면 Git은 수정하려는 커밋 목록이 첨부된 스크립트를 텍스트 편집기로 열어준다.
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
이 커밋은 모두 log 명령과는 정반대의 순서로 나열된다.
log 명령을 실행하면 아래와 같은 결과를 볼 수 있다.
$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
위 결과의 역순임을 기억하자.
대화형 Rebase는 스크립트에 적혀 있는 순서대로
`HEAD~3`부터 적용하기 시작하고 위에서 아래로 각각의 커밋을 순서대로 수정한다.
순서대로 적용하는 것이기 때문에 제일 위에 있는 것이 최신이 아니라 가장 오래된 것이다.
특정 커밋에서 실행을 멈추게 하려면 스크립트를 수정해야 한다.
pick 이라는 단어를 'edit’로 수정하면 그 커밋에서 멈춘다.
가장 오래된 커밋 메시지를 수정하려면 아래와 같이 편집한다.
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
저장하고 편집기를 종료하면 Git은 목록에 있는 커밋 중에서 가장 오래된 커밋으로 이동하고, 아래와 같은 메시지를 보여주고, 명령 프롬프트를 보여준다.
$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with
       git commit --amend
Once you’re satisfied with your changes, run
       git rebase --continue
명령 프롬프트가 나타날 때 Git은 Rebase 과정에서 현재 정확히 뭘 해야 하는지 메시지로 알려준다.
아래와 같은 명령을 실행하고
$ git commit --amend
커밋 메시지를 수정하고 텍스트 편집기를 종료하고 나서
아래 명령을 실행한다.
$ git rebase --continue
이렇게 나머지 두 개의 커밋에 적용하면 끝이다.
다른 것도 pick을 edit로 수정해서 이 작업을 몇 번이든 반복할 수 있다.
매번 Git이 멈출 때마다 커밋을 정정할 수 있고 완료할 때까지 계속 할 수 있다.
커밋 순서 바꾸기
대화형 Rebase 도구로 커밋 전체를 삭제하거나 순서를 조정할 수 있다.
“added cat-file” 커밋을 삭제하고 다른 두 커밋의 순서를 변경하려면 아래와 같은 Rebase 스크립트를
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
아래와 같이 수정한다.
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
수정한 내용을 저장하고 편집기를 종료하면 Git은 브랜치를 이 커밋의 부모로 이동시키고서 310154e 와 f7f3f6d 를 순서대로 적용한다.
명령이 끝나고 나면 커밋 순서가 변경됐고 “added cat-file” 커밋이 제거된 것을 확인할 수 있다.
커밋 합치기
대화형 Rebase 명령을 이용하여 여러 개의 커밋을 꾹꾹 눌러서 커밋 하나로 만들어 버릴 수 있다.
Rebase 스크립트에 자동으로 포함된 도움말에 설명이 있다.
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
“pick” 이나 “edit” 말고 “squash” 를 입력하면 Git은 해당 커밋과 바로 이전 커밋을 합칠 것이고 커밋 메시지도 Merge 한다.
그래서 3개의 커밋을 모두 합치려면 스크립트를 아래와 같이 수정한다.
pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
저장하고 나서 편집기를 종료하면 Git은 3개의 커밋 메시지를 Merge 할 수 있도록 에디터를 바로 실행해준다.
# This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit
# This is the 2nd commit message:
updated README formatting and added blame
# This is the 3rd commit message:
added cat-file
이 메시지를 저장하면 3개의 커밋이 모두 합쳐진 커밋 한 개만 남는다.
커밋 분리하기
커밋을 분리한다는 것은 기존의 커밋을 해제하고(혹은 되돌려 놓고) Stage를 여러 개로 분리하고 나서 그것을 원하는 횟수만큼 다시 커밋하는 것이다.
예로 들었던 커밋 세 개 중에서 가운데 것을 분리해보자. 이 커밋의 “updated README formatting and added blame” 을 “updated README formatting” 과 “added blame” 으로 분리하는 것이다. rebase -i 스크립트에서 해당 커밋을 "edit"로 변경한다.
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
저장하고 나서 명령 프롬프트로 넘어간 다음에 그 커밋을 해제하고 그 내용을 다시 두 개로 나눠서 커밋하면 된다.
저장하고 편집기를 종료하면 Git은 제일 오래된 커밋의 부모로 이동하고서 f7f3f6d 과 310154e 을 처리하고 콘솔 프롬프트를 보여준다.
여기서 커밋을 해제하는 git reset HEAD^ 라는 명령으로 커밋을 해제한다. 그러면 수정했던 파일은 Unstaged 상태가 된다.
그다음에 파일을 Stage 한 후 커밋하는 일을 원하는 만큼 반복하고 나서 git rebase --continue 라는 명령을 실행하면 남은 Rebase 작업이 끝난다.
$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue
나머지 a5f4a0d 커밋도 처리되면 히스토리는 아래와 같다.
$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
다시 강조하지만 Rebase 하면 목록에 있는 모든 커밋의 SHA-1 값은 변경된다. 절대로 이미 서버에 Push 한 커밋을 수정하면 안 된다.
filter-branch는 포크레인
수정해야 하는 커밋이 너무 많아서 Rebase 스크립트로 수정하기 어려울 것 같으면 다른 방법을 사용하는 것이 좋다. 모든 커밋의 이메일 주소를 변경하거나 어떤 파일을 삭제하는 경우를 살펴보자.
filter-branch 라는 명령으로 수정할 수 있는데 Rebase가 삽이라면 이 명령은 포크레인이라고 할 수 있다. filter-branch 도 역시 수정하려는 커밋이 이미 공개돼서 다른 사람과 함께 공유하는 중이라면 사용하지 말아야 한다.
하지만, 잘 쓰면 꽤 유용하다.
filter-branch 가 유용한 경우를 예로 들어 설명하기 때문에 여기에서 대충 어떤 경우에 유용할지 배울 수 있다.
모든 커밋에서 파일을 제거하기
갑자기 누군가 생각 없이 git add . 같은 명령을 실행해서 공룡 똥 덩어리를 커밋했거나 실수로 암호가 포함된 파일을 커밋해서 이런 파일을 다시 삭제해야 하는 상황을 살펴보자.
이런 상황은 생각보다 자주 발생한다.
filter-branch 는 히스토리 전체에서 필요한 것만 골라내는 데 사용하는 도구다.
filter-branch 의 --tree-filter 라는 옵션을 사용하면 히스토리에서 passwords.txt 파일을 아예 제거할 수 있다.
$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten
--tree-filter 옵션은 프로젝트를 Checkout 한 후에 각 커밋에 명시한 명령을 실행시키고 그 결과를 다시 커밋한다.
이 경우에는 각 스냅샷에 passwords.txt 파일이 있으면 그 파일을 삭제한다.
실수로 편집기의 백업파일을 커밋했으면 git filter-branch --tree-filter 'rm -f *~' HEAD 라고 실행해서 삭제할 수 있다.
이 명령은 모든 파일과 커밋을 정리하고 브랜치 포인터를 다시 복원해준다.
이런 작업은 테스팅 브랜치에서 실험하고 나서 master 브랜치에 적용하는 게 좋다.
filter-branch 명령에 --all 옵션을 추가하면 모든 브랜치에 적용할 수 있다.
하위 디렉토리를 루트 디렉토리로 만들기
다른 VCS에서 코드를 임포트하면 그 VCS만을 위한 디렉토리가 있을 수 있다. SVN에서 코드를 임포트하면 trunk, tags, branch 디렉토리가 포함된다.
모든 커밋에 대해 trunk 디렉토리를 프로젝트 루트 디렉토리로 만들 때도 filter-branch 명령이 유용하다.
$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
이제 trunk 디렉토리를 루트 디렉토리로 만들었다.
Git은 입력한 디렉토리와 관련이 없는 커밋을 자동으로 삭제한다.
모든 커밋의 이메일 주소를 수정하기
프로젝트를 오픈소스로 공개할 때 아마도 회사 이메일 주소로 커밋된 것을 개인 이메일 주소로 변경해야 한다. 아니면 아예 git config 로 이름과 이메일 주소를 설정하는 것을 잊었을 수도 있다.
자신의 이메일 주소만 변경하도록 조심해야 한다.
filter-branch 명령의 --commit-filter 옵션을 사용하여 해당 커밋만 골라서 이메일 주소를 수정할 수 있다.
$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
이메일 주소를 새 주소로 변경했다.
모든 커밋은 부모의 SHA-1 값을 가지고 있기 때문에 조건에 만족하는 커밋의 SHA-1값만 바뀌는 것이 아니라 모든 커밋의 SHA-1 값이 바뀐다.
prev | next
    About this site
    Patches, suggestions, and comments are welcome.
    Git is a member of Software Freedom Conservancy
